<!DOCTYPE html><html lang=en><meta charset=utf-8>
  <title>Streams Standard</title>
  <link href=https://www.whatwg.org/style/specification rel=stylesheet>
  <link href=https://resources.whatwg.org/logo-streams.svg rel=icon>
<script async src=//resources.whatwg.org/file-bug.js></script>
  <body class=h-entry>
<div class=head>
  <p data-fill-with=logo><a class=logo href=http://www.whatwg.org/>
    <img alt=WHATWG height=100 src=https://resources.whatwg.org/logo-streams.svg>
</a>
</p>
  <h1 class="p-name no-ref" id=title>Streams</h1>
  <h2 class="no-num no-toc no-ref heading settled" id=subtitle><span class=content>A Collection of Interesting Ideas,
    <span class=dt-updated><span class=value-title title=20141002>2 October 2014</span></span></span></h2>
  <div data-fill-with=spec-metadata><dl><dt>This version:<dd><a class=u-url href=https://whatwg.github.io/streams>https://whatwg.github.io/streams</a><dt>Editor:<dd><div class="p-author h-card vcard"><a class="p-name fn u-url url" href=http://domenic.me>Domenic Denicola</a> (<span class="p-org org">&lt;a href="https://www.google.com/"&gt;Google&lt;/a&gt;</span>) <a class="u-email email" href=mailto:domenic@domenicdenicola.com>domenic@domenicdenicola.com</a></div><dt>Version History:<dd><span><a href=https://github.com/whatwg/streams/commits>https://github.com/whatwg/streams/commits</a></span><dt>Participate:<dd><span><a href=https://github.com/whatwg/streams/issues/new>File an issue</a> (<a href="https://github.com/whatwg/streams/issues?state=open">open issues</a>)</span><dd><span>Send feedback to <a href=http://www.whatwg.org/mailing-list>whatwg@whatwg.org</a> (<a href=http://www.whatwg.org/mailing-list#specs>archives</a>)</span><dd><span><a href=http://wiki.whatwg.org/wiki/IRC>IRC: #whatwg on Freenode</a></span></dl></div>
  <div data-fill-with=warning></div>
  <p class=copyright data-fill-with=copyright><a href=http://creativecommons.org/publicdomain/zero/1.0/ rel=license><img alt=CC0 src=https://i.creativecommons.org/p/zero/1.0/80x15.png></a>
To the extent possible under law, the editors have waived all copyright
and related or neighboring rights to this work.
In addition, as of 2 October 2014,
the editors have made this specification available under the
<a href=http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0 rel=license>Open Web Foundation Agreement Version 1.0</a>,
which is available at http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.
Parts of this work may be from another specification document.  If so, those parts are instead covered by the license of that specification document.
</p>
  <hr title="Separator for header">
</div>

<h2 class="no-num no-toc no-ref heading settled" id=abstract><span class=content>Abstract</span></h2>
<div class=p-summary data-fill-with=abstract><p>This specification provides APIs for creating, composing, and consuming streams of data.

These streams are designed to map efficiently to low-level I/O primitives, and allow easy
composition with built-in backpressure and queuing. On top of streams, the web platform can
build higher-level abstractions, such as filesystem or socket APIs, while at the same time
users can use the supplied tools to build their own streams which integrate well with those
of the web platform.</p>

</div>
<div data-fill-with=at-risk></div>

<h2 class="no-num no-toc no-ref heading settled" id=contents><span class=content>Table of Contents</span></h2>
<div data-fill-with=table-of-contents><ul class=toc><li><a href=#model><span class=secno>1</span> <span class=content>Model</span></a><ul class=toc><li><a href=#rs-model><span class=secno>1.1</span> <span class=content>Readable Streams</span></a><li><a href=#ws-model><span class=secno>1.2</span> <span class=content>Writable Streams</span></a><li><a href=#ts-model><span class=secno>1.3</span> <span class=content>Transform Streams</span></a><li><a href=#pipe-chains><span class=secno>1.4</span> <span class=content>Pipe Chains and Backpressure</span></a></ul><li><a href=#rs><span class=secno>2</span> <span class=content>Readable Streams</span></a><ul class=toc><li><a href=#rs-intro><span class=secno>2.1</span> <span class=content>Introduction to Readable Streams</span></a><li><a href=#rs-state-diagram><span class=secno>2.2</span> <span class=content>The Readable Stream State Diagram</span></a><li><a href=#rs-class><span class=secno>2.3</span> <span class=content>Class <code>ReadableStream</code></span></a></ul><li><a href=#ws><span class=secno>3</span> <span class=content>Writable Streams</span></a><ul class=toc><li><a href=#ws-intro><span class=secno>3.1</span> <span class=content>Introduction to Writable Streams</span></a><li><a href=#ws-state-diagram><span class=secno>3.2</span> <span class=content>The Writable Stream State Diagram</span></a><li><a href=#ws-class><span class=secno>3.3</span> <span class=content>Class <code>WritableStream</code></span></a></ul><li><a href=#subclassing><span class=secno>4</span> <span class=content>Subclassing Streams</span></a><li><a href=#other-apis><span class=secno>5</span> <span class=content>Other Stream APIs</span></a><ul class=toc><li><a href=#tee-stream><span class=secno>5.1</span> <span class=content><code>TeeStream</code></span></a><li><a href=#ByteLengthQueuingStrategy><span class=secno>5.2</span> <span class=content><code>ByteLengthQueuingStrategy</code></span></a><li><a href=#CountQueuingStrategy><span class=secno>5.3</span> <span class=content><code>CountQueuingStrategy</code></span></a></ul><li><a href=#acks><span class=secno></span> <span class=content>Acknowledgments</span></a><li><a href=#conformance><span class=secno></span> <span class=content>Conformance</span></a><li><a href=#references><span class=secno></span> <span class=content>References</span></a><ul class=toc><li><a href=#normative><span class=secno></span> <span class=content>Normative References</span></a><li><a href=#informative><span class=secno></span> <span class=content>Informative References</span></a></ul><li><a href=#index><span class=secno></span> <span class=content>Index</span></a></ul></div>



<h2 class="no-num no-toc heading settled" id=status><span class=content>Status</span></h2>

<p>This specification is in the process of establishing itself in the WHATWG. As such, the term "Living Standard"
indicates a goal, rather than reality.</p>

<p>Although the core algorithms and APIs are largely present and working, prototyping and testing of them is still
underway, and there is still room for additional APIs beyond those specified here. Please join us in the
<a href="https://github.com/whatwg/streams/issues?state=open">issue tracker</a> for more discussion.</p>


<h2 class="heading settled" data-level=1 id=model><span class=secno>1. </span><span class=content>Model</span><a class=self-link href=#model></a></h2>

<p>A <dfn data-dfn-type=dfn data-noexport="" id=chunk>chunk<a class=self-link href=#chunk></a></dfn> is a single piece of data that is written to or read from a stream. It can be of any type; streams
can even contain chunks of different types. A chunk will often not be the most atomic unit of data for a given stream;
for example a binary stream might contain chunks consisting of 16 KiB <code>ArrayBuffer</code>s, instead of single
bytes.</p>

<h3 class="heading settled" data-level=1.1 id=rs-model><span class=secno>1.1. </span><span class=content>Readable Streams</span><a class=self-link href=#rs-model></a></h3>

<p>A <dfn data-dfn-type=dfn data-noexport="" id=readable-stream>readable stream<a class=self-link href=#readable-stream></a></dfn> represents a source of data, from which you can read. In other words, data comes
<em>out</em> of a readable stream.</p>

<p>Although a readable stream can be created with arbitrary behavior, most readable streams wrap a lower-level I/O source,
called the <dfn data-dfn-type=dfn data-noexport="" id=underlying-source>underlying source<a class=self-link href=#underlying-source></a></dfn>. There are two types of underlying source: push sources and pull sources.</p>

<p><dfn data-dfn-type=dfn data-noexport="" id=push-source title="push source">Push sources<a class=self-link href=#push-source></a></dfn> push data at you, whether or not you are listening for it. They may also provide a mechanism
for pausing and resuming the flow of data. An example push source is a TCP socket, where data is constantly being pushed
from the OS level, at a rate that can be controlled by changing the TCP window size.</p>

<p><dfn data-dfn-type=dfn data-noexport="" id=pull-source title="pull source">Pull sources<a class=self-link href=#pull-source></a></dfn> require you to request data from them. The data may be available synchronously, e.g. if it is
held by the operating system’s in-memory buffers, or asynchronously, e.g. if it has to be read from disk. An example
pull source is a file handle, where you seek to specific locations and read specific amounts.</p>

<p>Readable streams are designed to wrap both types of sources behind a single, unified interface.</p>

<p><a data-link-type=dfn href=#chunk title=Chunks>Chunks</a> are enqueued into the stream by the stream’s creator, who usually derives them from the <a data-link-type=dfn href=#underlying-source title="underlying source">underlying
source</a>. They can then be read one at a time via the stream’s public interface.</p>

<h3 class="heading settled" data-level=1.2 id=ws-model><span class=secno>1.2. </span><span class=content>Writable Streams</span><a class=self-link href=#ws-model></a></h3>

<p>A <dfn data-dfn-type=dfn data-noexport="" id=writable-stream>writable stream<a class=self-link href=#writable-stream></a></dfn> represents a destination for data, into which you can write. In other words, data goes
<em>in</em> to a writable stream.</p>

<p>Analogously to readable streams, most writable streams wrap a lower-level I/O sink, called the
<dfn data-dfn-type=dfn data-noexport="" id=underlying-sink>underlying sink<a class=self-link href=#underlying-sink></a></dfn>. Writable streams work to abstract away some of the complexity of the underlying sink, by
queuing subsequent writes and only delivering them to the underlying sink one by one.</p>

<p><a data-link-type=dfn href=#chunk title=Chunks>Chunks</a> are enqueued into the stream via its public interface, and are passed one at a time to the stream’s
creator. In turn, the creator will usually forward them to the <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a>.</p>

<h3 class="heading settled" data-level=1.3 id=ts-model><span class=secno>1.3. </span><span class=content>Transform Streams</span><a class=self-link href=#ts-model></a></h3>

<p>A <dfn data-dfn-type=dfn data-noexport="" id=transform-stream>transform stream<a class=self-link href=#transform-stream></a></dfn> consists of a pair of streams: a writable stream, and a readable stream.
In a manner specific to the transform stream in question, writes to the writable side result in new data being made
available for reading from the readable side.</p>

<p>Some examples of transform streams include:</p>

<ul>
  <li>A text decoder, to which bytes are written and from which strings are read;</li>
  <li>A GZIP compressor, to which uncompressed bytes are written and from which compressed bytes are read;</li>
  <li>A video decoder, to which encoded bytes are writen and from which uncompressed video frames are read.</li>
</ul>

<h3 class="heading settled" data-level=1.4 id=pipe-chains><span class=secno>1.4. </span><span class=content>Pipe Chains and Backpressure</span><a class=self-link href=#pipe-chains></a></h3>

<p>Streams are primarily used by <dfn data-dfn-type=dfn data-noexport="" id=piping>piping<a class=self-link href=#piping></a></dfn> them to each other. A readable stream can be piped directly to a
writable stream, or it can be piped through one or more transform streams first.</p>

<p>A set of streams piped together in this way is referred to as a <dfn data-dfn-type=dfn data-noexport="" id=pipe-chain>pipe chain<a class=self-link href=#pipe-chain></a></dfn>. In a pipe chain, the
<dfn data-dfn-type=dfn data-noexport="" id=ultimate-producer>ultimate producer<a class=self-link href=#ultimate-producer></a></dfn> is the first readable stream in the chain; the <dfn data-dfn-type=dfn data-noexport="" id=ultimate-consumer>ultimate consumer<a class=self-link href=#ultimate-consumer></a></dfn> is the final
writable stream in the chain.</p>

<p>Once a pipe chain is constructed, it can be used to propagate signals regarding how fast data should flow through
it. If any step in the chain cannot yet accept data, it propagates a signal backwards through the pipe chain, until
eventually the ultimate producer is told to stop producing data so fast. This process of normalizing data flow from the
ultimate producer according to how fast the chain can process data is called <dfn data-dfn-type=dfn data-noexport="" id=backpressure>backpressure<a class=self-link href=#backpressure></a></dfn>.</p>

<h2 class="heading settled" data-level=2 id=rs><span class=secno>2. </span><span class=content>Readable Streams</span><a class=self-link href=#rs></a></h2>

<h3 class="heading settled" data-level=2.1 id=rs-intro><span class=secno>2.1. </span><span class=content>Introduction to Readable Streams</span><a class=self-link href=#rs-intro></a></h3>

<p><em>This section is non-normative.</em></p>

<p>The readable stream API allows wrapping both pull and push sources into a single <code>ReadableStream</code>
abstraction. To accomplish this, the API uses the
<a href=http://domenic.me/2014/02/14/the-revealing-constructor-pattern/>revealing constructor pattern</a>. The
constructor of a given stream instance is supplied with two functions, <code>start</code> and <code>pull</code>, which
each are given the parameters <code>(enqueue, close, error)</code> representing capabilities tied to the internals of the
stream. By mediating all access to the internal state machine through these three functions, the stream’s internal
state and bookkeeping can be kept private, allowing nobody but the original producer of the stream to insert data into
it.</p>

<div class=example>
  The following function creates readable streams that wrap web sockets <a data-biblio-type=informative data-link-type=biblio href=#biblio-html title=HTML>[HTML]</a>, which are push sources that do not
  support backpressure signals.

  <pre>function makeReadableWebSocketStream(url, protocols) {
  const ws = new WebSocket(url, protocols);
  ws.binaryType = "arraybuffer";
  return new ReadableStream({
    start(enqueue, close, error) {
      // When adapting a push source, usually most of the work happens in start.
      ws.onmessage = event =&gt; enqueue(event.data);
      ws.onend = close;
      ws.onerror = error;
    },
    cancel() {
      ws.close();
    }
  });
}
</pre>

<p>We can then use this function to create readable streams for web sockets, and pipe those streams to arbitrary
  writable streams:</p>

  <pre>var webSocketStream = makeReadableWebSocketStream("http://example.com", 80);
socketStream.pipeTo(writableStream).closed
  .then(() =&gt; console.log("All data successfully written!"))
  .catch(e =&gt; console.error("Something went wrong!", e));
</pre>
</div>

<div class=example>
  The following function wraps a push source, represented by a hypothetical "raw socket" interface, which triggers
  events for data, end, and error (much like a web socket), but also provides the ability to pause and resume the flow
  of data. Thus, this example shows how to apply backpressure to <a data-link-type=dfn href=#underlying-source title="underlying sources">underlying sources</a> that support it.

  <pre>function makeSocketStream(host, port) {
  const rawSocket = createRawSocketObject(host, port);
  return new ReadableStream({
    start(enqueue, close, error) {
      rawSocket.ondata = event =&gt; {
        if (!enqueue(event.data)) {
          // If enqueue returns false, the internal queue is full, so propagate
          // the backpressure signal to the underlying source.
          rawSocket.readStop();
        }
      };
      rawSocket.onend = close;
      rawSocket.onerror = error;
    },
    pull() {
      // This is called if the internal queue has been emptied, but the
      // stream’s consumer still wants more data. In that case, restart
      // the flow of data if we have previously paused it.
      rawSocket.readStart();
    },
    cancel() {
      rawSocket.readStop();
    }
  });
}
</pre>

<p>We can then use this function to create readable streams for such "raw sockets" in the same way we do for web
  sockets. This time, however, when we pipe to a destination that cannot accept data as fast as the socket is producing
  it, a backpressure signal will be sent to the raw socket.
</div><p></p>

<div class=example>
  The following function wraps a pull source, represented by a "raw file handle," which provides methods for opening,
  reading from, and closing itself. These methods can call their callbacks either synchronously or asynchronously—a
  <a href=http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony>Zalgo-releasing</a> horror which we can
  hide from our users by wrapping them in a readable stream.

  <pre>function makeReadableFileStream(filename) {
  const fileHandle = createRawFileHandle(filename, "r");
  return new ReadableStream({
    start() {
      return new Promise((resolve, reject) =&gt; {
        fileHandle.open(err =&gt; {
          if (err) {
            reject(err);
          }
          resolve();
        });
      });
    },
    pull(enqueue, close, error) {
      // When adapting a pull source, usually most of the work happens in pull.
      fileHandle.read((err, isDone, chunk) =&gt; {
        if (err) {
          // If trying to read data results in an error, report that.
          error(err);
        } else if (isDone) {
          // If there’s no more data to read, be sure to close the underlying
          // source, ensuring that it succeeds before reporting success.
          fileHandle.close(err =&gt; {
            if (err) {
              error(err);
            }
            close();
          });
        } else {
          // If data was read successfully, enqueue it into the internal queue.
          enqueue(chunk);
        }
      });
    },
    cancel() {
      fileHandle.close();
    }
  });
}
</pre>

<p>We can then create and use readable streams for files just as we could before for sockets.
</div><p></p>

<div class=example>
  Although readable streams will usually be used by piping them to a writable stream, you can also "pump" them
  directly, alternating between using the <code>read()</code> and <code>wait()</code> methods according to the current
  value of the <code>state</code> property. For example, this function writes the contents of a readable stream to the
  console as fast as they are available.

  <pre>function streamToConsole(readableStream) {
  pump();
  function pump() {
    while (readableStream.state === "readable") {
      console.log(readableStream.read());
    }
    if (readableStream.state === "closed") {
      console.log("--- all done!");
    } else {
      // If we’re in an error state, the returned promise will be rejected with
      // that error, so no need to handle "waiting" vs. "errored" separately.
      readableStream.wait().then(pump, e =&gt; console.error(e));
    }
  }
}
</pre>
</div>

<h3 class="heading settled" data-level=2.2 id=rs-state-diagram><span class=secno>2.2. </span><span class=content>The Readable Stream State Diagram</span><a class=self-link href=#rs-state-diagram></a></h3>

<p><em>This section is non-normative.</em></p>

<p>As evidenced by the above explanations, readable streams have a fairly complex internal state machine, which is
responsible for keeping track of the internal queue, and initiating appropriate actions in response to calls to a
stream’s methods. This can be roughly summarized in the following diagram.</p>

<figure>
  <img alt="The readable stream state machine diagram." src=readable-stream.svg width=578>

  <figcaption>
    <dl>
      <dt><span style="font-style: normal; font-weight: normal; font-family: monospace;">monospace</span></dt>
      <dd>Methods of the stream</dd>

      <dt><span style="font-style: normal; font-weight: bold;">bold</span></dt>
      <dd>Constructor parameters</dd>

      <dt><span style="font-style: italic; font-weight: normal;">italic</span></dt>
      <dd>Capabilities given to constructor parameters</dd>
    </dl>
  </figcaption>
</figure>


<h3 class="heading settled" data-level=2.3 id=rs-class><span class=secno>2.3. </span><span class=content>Class <code>ReadableStream</code></span><a class=self-link href=#rs-class></a></h3>

<h2 class="heading settled" data-level=3 id=ws><span class=secno>3. </span><span class=content>Writable Streams</span><a class=self-link href=#ws></a></h2>

<h3 class="heading settled" data-level=3.1 id=ws-intro><span class=secno>3.1. </span><span class=content>Introduction to Writable Streams</span><a class=self-link href=#ws-intro></a></h3>

<p><em>This section is non-normative.</em></p>

<p>The writable stream API allows wrapping of <a data-link-type=dfn href=#underlying-sink title="underlying sinks">underlying sinks</a> into an object on which two fundamental operations
can be performed: data can be written to the stream, and the stream can be closed.</p>

<p>The writable stream implementation is designed to encapsulate the potential complexity of the <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a>
from users of the stream API. In particular, users of a stream object can write data to the stream at any pace, without
regard for whether previous writes have completed or succeeded. It is the job of the stream implementation to ensure
that writes are forwarded to the <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a> in order, and only after successful completion of previous writes.
This allows seamless use of the writable stream even in cases such as piping a fast readable file stream to a slower
writable network socket stream, which cannot acknowledge the incoming data at the same rate it becomes available.</p>

<div class=example>
  The following function wraps a web socket <a data-biblio-type=informative data-link-type=biblio href=#biblio-html title=HTML>[HTML]</a> as the <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a> of a new writable stream. Web
  sockets do not provide any way to tell when a given chunk of data has been successfully sent, so this writable stream
  has no ability to communicate backpressure signals to any users: it will always be in the <code>"writable"</code>
  state.

  <pre>function makeWritableWebSocketStream(url, protocols) {
  const ws = new WebSocket(url, protocols);
  return new WritableStream({
    start(error) {
      ws.onerror = error;
      return new Promise(resolve =&gt; ws.onopen = resolve);
    },
    write(chunk) {
      ws.send(chunk);
      // Return immediately, since the web socket gives us no way to tell
      // when the write completes.
    },
    close() {
      return new Promise((resolve, reject) =&gt; {
        ws.onclose = resolve;
        ws.close();
      });
    }
  });
}
</pre>
</div>

<div class=example>
  The following function wraps an <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a>, represented as a hypothetical "raw file handle," which
  provides methods for opening, writing to, and closing itself. Notably, the raw file handle’s <code>write</code> method
  calls back to signal when writes are complete, which allows the stream to correctly communicate backpressure signals
  to any users by setting its state to <code>"waiting"</code> instead of <code>"writable"</code> when the queue gets too
  full. Allow of the raw file handle’s methods can call their callbacks either synchronously or asynchronously—a
  <a href=http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony>Zalgo-releasing</a> horror which we can
  hide from our users by wrapping them in a writable stream.

  <pre>function makeWritableFileStream(filename) {
  const fileHandle = createRawFileHandle(filename, "w");
  return new WritableStream({
    start() {
      return new Promise((resolve, reject) =&gt; {
        fileHandle.open(err =&gt; {
          if (err) {
            reject(err);
          }
          resolve();
        });
      });
    },
    write(chunk) {
      return new Promise((resolve, reject) =&gt; {
        fileHandle.write(chunk, writeErr =&gt; {
          if (writeErr) {
            // If trying to write results in an error, (attempt to) close the
            // underlying file handle; we’re not going to write any more.
            fileHandle.close(closeErr =&gt; {
              // If *closing* errors, pass along that error to the stream.
              if (closeErr) {
                reject(closeErr);
              }
              // Otherwise, if closing succeeds, pass along the write error.
              reject(writeErr);
            });
          } else {
            // If there’s no error, then signal that this write completed.
            resolve();
          }
        });
      });
    },
    close() {
      return new Promise((resolve, reject) =&gt; {
        fileHandle.close(err =&gt; {
          if (err) {
            reject(err);
          }
          resolve();
        });
      });
    }
  });
}
</pre>

<p>We can then use this function to create a writable stream for a file, and then pipe a readable stream to it:</p>

  <pre>var fileStream = makeWritableFileStream("/example/path/on/fs.txt");
readableStream.pipeTo(fileStream).closed
  .then(() =&gt; console.log("All data successfully written!"))
  .catch(e =&gt; console.error("Something went wrong!", e));
</pre>

<p>Note that if a particular call to <code>fileHandle.write</code> takes a longer time, <code>done</code> will be
  called later. In the meantime, additional writes can be queued up, which are stored in the stream’s internal queue.
  The accumulation of this queue can move the stream into a <code>"waiting"</code> state, which is a signal to users
  of the stream that they should back off and stop writing if possible.
</div><p></p>

<div class=example>
  Although writable streams will usually be used by piping to them from a readable stream, you can also write to them
  directly. Since they queue any incoming writes, and take care internally to forward them to the <a data-link-type=dfn href=#underlying-sink title="underlying sink">underlying sink</a>
  in sequence, you can indiscriminately write to a writable stream without much ceremony:

  <pre>function writeArrayToStream(array, writableStream) {
  array.forEach(chunk =&gt; writableStream.write(chunk));
  return writableStream.close();
}
writeArrayToStream([1, 2, 3, 4, 5], writableStream)
  .then(() =&gt; console.log("All done!"))
  .catch(e =&gt; console.error("Error with the stream: " + e));
</pre>
</div>

<h3 class="heading settled" data-level=3.2 id=ws-state-diagram><span class=secno>3.2. </span><span class=content>The Writable Stream State Diagram</span><a class=self-link href=#ws-state-diagram></a></h3>

<p><em>This section is non-normative.</em></p>

<p>TODO</p>

<h3 class="heading settled" data-level=3.3 id=ws-class><span class=secno>3.3. </span><span class=content>Class <code>WritableStream</code></span><a class=self-link href=#ws-class></a></h3>

<h2 class="heading settled" data-level=4 id=subclassing><span class=secno>4. </span><span class=content>Subclassing Streams</span><a class=self-link href=#subclassing></a></h2>

<p><em>This section is non-normative.</em></p>

<p>Specific APIs may wish to subclass <code>ReadableStream</code> or <code>WritableStream</code> in order to provide
additional functionality. Examples would include:</p>

<ul>
  <li>A file stream that is constructed from a filename, and includes file metadata</li>
  <li>A HTTP stream that is constructed from a URL, and includes header-accessing APIs</li>
  <li>A TCP stream that overrides <code>read</code>, <code>wait</code>, <code>cancel</code>, <code>state</code>, and
  <code>closed</code> to reflect and manipulate a kernel-level TCP buffer</li>
</ul>

<p>The first two examples here could be expressed by allowing their constructors to call <code>super</code> with
appropriate functions that manipulate the stream’s internal state. The latter takes a different approach, which gives
both more power and more responsibility: it requires that the author of that stream manually implement many of the
complex requirements baked into the readable stream state machine and the contract it presents to users.</p>

<p>Because streams only interact through their public API, all streams—whether subclassed or not—can coexist and
interoperate. For example, you can pipe to or from any of the above streams, without worrying what type of
implementation is under the covers, since they all provide the appropriate properties and methods.</p>

<h2 class="heading settled" data-level=5 id=other-apis><span class=secno>5. </span><span class=content>Other Stream APIs</span><a class=self-link href=#other-apis></a></h2>

<h3 class="heading settled" data-level=5.1 id=tee-stream><span class=secno>5.1. </span><span class=content><code>TeeStream</code></span><a class=self-link href=#tee-stream></a></h3>

<h3 class="heading settled" data-level=5.2 id=ByteLengthQueuingStrategy><span class=secno>5.2. </span><span class=content><code>ByteLengthQueuingStrategy</code></span><a class=self-link href=#ByteLengthQueuingStrategy></a></h3>

<h3 class="heading settled" data-level=5.3 id=CountQueuingStrategy><span class=secno>5.3. </span><span class=content><code>CountQueuingStrategy</code></span><a class=self-link href=#CountQueuingStrategy></a></h3>

<h2 class="no-num heading settled" id=acks><span class=content>Acknowledgments</span><a class=self-link href=#acks></a></h2>

<p>The editor would like to thank
Tab Atkins,
Bert Belder,
Marcos Caceres,
Tim Caswell,
Forbes Lindesay,
Thorsten Lorenz,
Michael Mior,
Jens Nockert,
Trevor Norris,
Dominic Tarr, and
tzik
for their contributions to this specification.</p>

<p>Special thanks to:
Will Chan for his help ensuring that the API allows high-performance network streaming,
Gorgi Kosev for his breakthrough idea of separating piping into two methods, thus resolving
  <a href=https://github.com/whatwg/streams/issues/44>a major sticking point</a>;
Forrest Norvell for his enthusiastic iteration on the reference implementation;
Isaac Schlueter for his pioneering work on JavaScript streams in Node.js;
Jake Verbaten for his continued involvement, support, and interest in pushing this spec forward; and
Takeshi Yoshino for his careful review of and contributions to this spec’s algorithms and concepts.</p>

<h2 class="no-num no-ref heading settled" id=conformance><span class=content>Conformance</span><a class=self-link href=#conformance></a></h2>

<p>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked
non-normative. Everything else in this specification is normative.

<p>The key words "MUST", "MUST NOT", "REQUIRED",  "SHOULD", "SHOULD NOT", "RECOMMENDED",
"MAY", and "OPTIONAL" in the normative parts of this specification are to be interpreted as described in RFC2119. For
readability, these words do not appear in all uppercase letters in this specification. <a data-biblio-type=normative data-link-type=biblio href=#biblio-rfc2119 title=RFC2119>[RFC2119]</a>

<p>Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end
result is equivalent.
<h2 class="no-num heading settled" id=references><span class=content>References</span><a class=self-link href=#references></a></h2><h3 class="no-num heading settled" id=normative><span class=content>Normative References</span><a class=self-link href=#normative></a></h3><dl><dt id=biblio-rfc2119 title=rfc2119><a class=self-link href=#biblio-rfc2119></a>[rfc2119]<dd>S. Bradner. <a href=http://www.ietf.org/rfc/rfc2119.txt>Key words for use in RFCs to Indicate Requirement Levels</a>. Best Current Practice. URL: <a href=http://www.ietf.org/rfc/rfc2119.txt>http://www.ietf.org/rfc/rfc2119.txt</a></dl><h3 class="no-num heading settled" id=informative><span class=content>Informative References</span><a class=self-link href=#informative></a></h3><dl><dt id=biblio-html title=HTML><a class=self-link href=#biblio-html></a>[HTML]<dd>Ian Hickson. <a href=https://html.spec.whatwg.org/>HTML</a>. Living Standard. URL: <a href=https://html.spec.whatwg.org/>https://html.spec.whatwg.org/</a></dl><h2 class="no-num heading settled" id=index><span class=content>Index</span><a class=self-link href=#index></a></h2><ul class=indexlist><li>backpressure, <a href=#backpressure title="section 1.4">1.4</a><li>chunk, <a href=#chunk title="section 1">1</a><li>pipe chain, <a href=#pipe-chain title="section 1.4">1.4</a><li>piping, <a href=#piping title="section 1.4">1.4</a><li>pull source, <a href=#pull-source title="section 1.1">1.1</a><li>push source, <a href=#push-source title="section 1.1">1.1</a><li>readable stream, <a href=#readable-stream title="section 1.1">1.1</a><li>transform stream, <a href=#transform-stream title="section 1.3">1.3</a><li>ultimate consumer, <a href=#ultimate-consumer title="section 1.4">1.4</a><li>ultimate producer, <a href=#ultimate-producer title="section 1.4">1.4</a><li>underlying sink, <a href=#underlying-sink title="section 1.2">1.2</a><li>underlying source, <a href=#underlying-source title="section 1.1">1.1</a><li>writable stream, <a href=#writable-stream title="section 1.2">1.2</a></ul>