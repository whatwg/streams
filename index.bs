<pre class="metadata">
Title: Streams Standard
Group: WHATWG
H1: Streams
Shortname: streams
Status: LS
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: This specification provides APIs for creating, composing, and consuming streams of data.
Abstract: These streams are designed to map efficiently to low-level I/O primitives, and allow easy
Abstract: composition with built-in backpressure and queuing. On top of streams, the web platform can
Abstract: build higher-level abstractions, such as filesystem or socket APIs, while at the same time
Abstract: users can use the supplied tools to build their own streams which integrate well with those
Abstract: of the web platform.
Logo: https://resources.whatwg.org/logo-streams.svg
!Participate: <a href="https://github.com/whatwg/streams/issues/new">File an issue</a> (<a href="https://github.com/whatwg/streams/issues?state=open">open issues</a>)
!Participate: <a href="http://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
!Version History: <a href="https://github.com/whatwg/streams/commits">https://github.com/whatwg/streams/commits</a>
!Version History: <a href="https://twitter.com/streamsstandard">@streamsstandard</a>
</pre>

<style>
  ol > li { margin: 0; }
  .note + .example { margin-top: 1em; }

  /* Self-link styles */
  .heading {
    position: relative;
  }
  a.self-link {
    position: absolute;
    top: 0;
    left: -2.5em;
    width: 2em;
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
  }
  a.self-link:hover {
    opacity: 1;
    text-decoration: none;
  }
  .heading > a.self-link {
    font-size: 83%;
    color: inherit;
  }
  li > a.self-link {
    left: -3.5em;
  }
  dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: gray;
    color: white;
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
  }
  dfn:hover > a.self-link {
    opacity: 1;
  }
  dfn > a.self-link:hover {
    color: black;
    background-color: #B1C99D;
  }
  a.self-link::before {
    content: "¶";
  }
  .heading > a.self-link::before {
    content: "§";
  }
  dfn > a.self-link::before {
    content: "#";
  }

  /* Hide editor visually, but leave it for scraping tools */
  .head .editor {
    display: none;
  }
</style>
<script src="https://resources.whatwg.org/file-issue.js" async></script>


<h2 id="intro">Introduction</h2>

<em>This section is non-normative.</em>

Large swathes of the web platform are built on streaming data: that is, data that is created, processed, and consumed
in an incremental fashion, without ever reading all of it into memory. The Streams Standard provides a common set of
APIs for creating and interfacing with such streaming data, embodied in <a>readable streams</a>,
<a>writable streams</a>, and <a>transform streams</a>.

This standard provides the base stream primitives which other parts of the web platform can use to expose their
streaming data. For example, [[FETCH]] could expose request bodies as a writable stream, or response bodies as a
readable stream. More generally, the platform is full of streaming abstractions waiting to be expressed as streams:
multimedia streams, file streams, interprocess communication, and more benefit from being able to process data
incrementally instead of buffering it all into memory and processing it in one go. By providing the foundation for
these streams to be exposed to developers, the Streams Standard enables use cases like:

<ul>
  <li> Video effects: piping a readable video stream through a transform stream that applies effects in real time.
  <li> Decompression: piping a file stream through a transform stream that selectively decompresses files from a
    <kbd>.tgz</kbd> archive, turning them into <code>img</code> elements as the user scrolls through an image gallery.
  <li> Image decoding: piping a HTTP response stream through a transform stream that decodes bytes into bitmap data,
    and then through another transform that translates bitmaps into PNGs. If installed inside the <code>fetch</code>
    hook of a service worker [[SERVICE-WORKERS]], this would allow developers to transparently polyfill new image
    formats.
</ul>

The APIs described here provide unifying abstraction for all such streams, encouraging an ecosystem to grow around
these shared and composable interfaces. At the same time, they have been carefully designed to map efficiently to
low-level I/O concerns, and to encapsulate the trickier issues (such as <a>backpressure</a>) that come along for the
ride.

<h2 id="model">Model</h2>

A <dfn>chunk</dfn> is a single piece of data that is written to or read from a stream. It can be of any type; streams
can even contain chunks of different types. A chunk will often not be the most atomic unit of data for a given stream;
for example a binary stream might contain chunks consisting of 16 KiB <code>ArrayBuffer</code>s, instead of single
bytes.

<h3 id="rs-model">Readable Streams</h3>

A <dfn>readable stream</dfn> represents a source of data, from which you can read. In other words, data comes
<em>out</em> of a readable stream.

Although a readable stream can be created with arbitrary behavior, most readable streams wrap a lower-level I/O source,
called the <dfn>underlying source</dfn>. There are two types of underlying source: push sources and pull sources.

<dfn title="push source">Push sources</dfn> push data at you, whether or not you are listening for it. They may also
provide a mechanism for pausing and resuming the flow of data. An example push source is a TCP socket, where data is
constantly being pushed from the OS level, at a rate that can be controlled by changing the TCP window size.

<dfn title="pull source">Pull sources</dfn> require you to request data from them. The data may be available
synchronously, e.g. if it is held by the operating system's in-memory buffers, or asynchronously, e.g. if it has to be
read from disk. An example pull source is a file handle, where you seek to specific locations and read specific amounts.

Readable streams are designed to wrap both types of sources behind a single, unified interface.

<a>Chunks</a> are enqueued into the stream by the stream's creator, who usually derives them from the <a>underlying
source</a>. They can then be read one at a time via the stream's public interface.

Code that reads from a readable stream using its public interface is known as a <dfn>consumer</dfn>.

<h3 id="ws-model">Writable Streams</h3>

A <dfn>writable stream</dfn> represents a destination for data, into which you can write. In other words, data goes
<em>in</em> to a writable stream.

Analogously to readable streams, most writable streams wrap a lower-level I/O sink, called the
<dfn>underlying sink</dfn>. Writable streams work to abstract away some of the complexity of the underlying sink, by
queuing subsequent writes and only delivering them to the underlying sink one by one.

<a>Chunks</a> are enqueued into the stream via its public interface, and are passed one at a time to the stream's
creator. In turn, the creator will usually forward them to the <a>underlying sink</a>.

Code that writes into a writable stream using its public interface is known as a <dfn>producer</dfn>.

<h3 id="ts-model">Transform Streams</h3>

A <dfn>transform stream</dfn> consists of a pair of streams: a writable stream, and a readable stream.
In a manner specific to the transform stream in question, writes to the writable side result in new data being made
available for reading from the readable side.

Some examples of transform streams include:

<ul>
  <li>A text decoder, to which bytes are written and from which strings are read;</li>
  <li>A GZIP compressor, to which uncompressed bytes are written and from which compressed bytes are read;</li>
  <li>A video decoder, to which encoded bytes are writen and from which uncompressed video frames are read.</li>
</ul>

<h3 id="pipe-chains">Pipe Chains and Backpressure</h3>

Streams are primarily used by <dfn>piping</dfn> them to each other. A readable stream can be piped directly to a
writable stream, or it can be piped through one or more transform streams first.

A set of streams piped together in this way is referred to as a <dfn>pipe chain</dfn>. In a pipe chain, the
<dfn>original source</dfn> is the <a>underlying source</a> of the first first readable stream in the chain; the
<dfn>ultimate sink</dfn> is the <a>underlying sink</a> of the final writable stream in the chain.

Once a pipe chain is constructed, it can be used to propagate signals regarding how fast data should flow through
it. If any step in the chain cannot yet accept data, it propagates a signal backwards through the pipe chain, until
eventually the original source is told to stop producing data so fast. This process of normalizing data flow from the
original source according to how fast the chain can process data is called <dfn>backpressure</dfn>.

<h3 id="queuing-strategies">Internal Queues and Queuing Strategies</h3>

Both readable and writable streams maintain <dfn>internal queues</dfn>, which they use for similar purposes. In the
case of a readable stream, the internal queue contains <a>chunks</a> that have been enqueued by the <a>underlying
source</a>, but not yet read by the consumer. In the case of a writable stream, the internal queue contains
<a>chunks</a> which have been written to the stream by the producer, but not yet processed and acknowledged by the
<a>underlying sink</a>.

A <dfn>queuing strategy</dfn> is a pair of methods that help determine whether a stream should apply
<a>backpressure</a> based on the state of its <a>internal queue</a>. The queuing strategy assigns a size to each
<a>chunk</a>; later, the stream implementation asks the queuing strategy whether the stream should apply backpressure,
based the total size of all chunks in the stream's internal queue.

<div class="example">
  A simple example of a queuing strategy would be one that assigns a size of one to each chunk, and applies
  backpressure whenever three or more chunks are in the internal queue. This would mean that up to three chunks could
  be enqueued in a readable stream, or three chunks could be written to a writable stream, before they send a
  backpressure signal.
</div>

<h2 id="rs">Readable Streams</h2>

<h3 id="rs-intro">Introduction to Readable Streams</h3>

<em>This section is non-normative.</em>

The readable stream API allows wrapping both pull and push sources into a single <code>ReadableStream</code>
abstraction. To accomplish this, the API uses the
<a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/">revealing constructor pattern</a>. The
constructor of a given stream instance is supplied with two functions, <code>start</code> and <code>pull</code>, which
each are given the parameters <code>(enqueue, close, error)</code> representing capabilities tied to the internals of
the stream. By mediating all access to the internal state machine through these three functions, the stream's internal
state and bookkeeping can be kept private, allowing nobody but the original producer of the stream to insert data into
it.

<div class="example">
  The following function creates readable streams that wrap web sockets [[HTML]], which are push sources that do not
  support backpressure signals.

  <pre><code class="lang-javascript">
    function makeReadableWebSocketStream(url, protocols) {
      const ws = new WebSocket(url, protocols);
      ws.binaryType = "arraybuffer";

      return new ReadableStream({
        start(enqueue, close, error) {
          // When adapting a push source, usually most of the work happens in start.

          ws.onmessage = event => enqueue(event.data);
          ws.onend = close;
          ws.onerror = error;
        },

        cancel() {
          ws.close();
        }
      });
    }
  </code></pre>

  We can then use this function to create readable streams for web sockets, and pipe those streams to arbitrary
  writable streams:

  <pre><code class="lang-javascript">
    var webSocketStream = makeReadableWebSocketStream("http://example.com", 80);

    webSocketStream.pipeTo(writableStream)
      .then(() => console.log("All data successfully written!"))
      .catch(e => console.error("Something went wrong!", e));
  </code></pre>
</div>

<div class="example">
  The following function wraps a push source, represented by a hypothetical "raw socket" interface, which triggers
  events for data, end, and error (much like a web socket), but also provides the ability to pause and resume the flow
  of data. Thus, this example shows how to apply backpressure to <a>underlying sources</a> that support it.

  <pre><code class="lang-javascript">
    function makeSocketStream(host, port) {
      const rawSocket = createRawSocketObject(host, port);

      return new ReadableStream({
        start(enqueue, close, error) {
          rawSocket.ondata = event => {
            if (!enqueue(event.data)) {
              // If enqueue returns false, the internal queue is full, so propagate
              // the backpressure signal to the underlying source.
              rawSocket.readStop();
            }
          };

          rawSocket.onend = close;
          rawSocket.onerror = error;
        },

        pull() {
          // This is called if the internal queue has been emptied, but the
          // stream's consumer still wants more data. In that case, restart
          // the flow of data if we have previously paused it.
          rawSocket.readStart();
        },

        cancel() {
          rawSocket.readStop();
        }
      });
    }
  </code></pre>

  We can then use this function to create readable streams for such "raw sockets" in the same way we do for web
  sockets. This time, however, when we pipe to a destination that cannot accept data as fast as the socket is producing
  it, a backpressure signal will be sent to the raw socket.
</div>

<div class="example">
  The following function wraps a pull source, represented by a "raw file handle," which provides methods for opening,
  reading from, and closing itself. These methods can call their callbacks either synchronously or asynchronously—a
  <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">Zalgo-releasing</a> horror which we can
  hide from our users by wrapping them in a readable stream.

  <pre><code class="lang-javascript">
    function makeReadableFileStream(filename) {
      const fileHandle = createRawFileHandle(filename, "r");

      return new ReadableStream({
        start() {
          return new Promise((resolve, reject) => {
            fileHandle.open(err => {
              if (err) {
                reject(err);
              }
              resolve();
            });
          });
        },

        pull(enqueue, close, error) {
          // When adapting a pull source, usually most of the work happens in pull.

          fileHandle.read((err, isDone, chunk) => {
            if (err) {
              // If trying to read data results in an error, report that.
              error(err);
            } else if (isDone) {
              // If there's no more data to read, be sure to close the underlying
              // source, ensuring that it succeeds before reporting success.
              fileHandle.close(err => {
                if (err) {
                  error(err);
                }
                close();
              });
            } else {
              // If data was read successfully, enqueue it into the internal queue.
              enqueue(chunk);
            }
          });
        },

        cancel() {
          fileHandle.close();
        }
      });
    }
  </code></pre>

  We can then create and use readable streams for files just as we could before for sockets.
</div>

<div class="example">
  Although readable streams will usually be used by piping them to a writable stream, you can also "pump" them
  directly, alternating between using the <code>read()</code> method and the <code>ready</code> getter according to the current
  value of the <code>state</code> property. For example, this function writes the contents of a readable stream to the
  console as fast as they are available.

  <pre><code class="lang-javascript">
    function streamToConsole(readableStream) {
      pump();

      function pump() {
        while (readableStream.state === "readable") {
          console.log(readableStream.read());
        }

        if (readableStream.state === "closed") {
          console.log("--- all done!");
        } else {
          // If we're in an error state, the returned promise will be rejected with
          // that error, so no need to handle "waiting" vs. "errored" separately.
          readableStream.ready.then(pump, e => console.error(e));
        }
      }
    }
  </code></pre>
</div>

<h3 id="rs-state-diagram">The Readable Stream State Diagram</h3>

<em>This section is non-normative.</em>

As evidenced by the above explanations, readable streams have a fairly complex internal state machine, which is
responsible for keeping track of the internal queue, and initiating appropriate actions in response to calls to a
stream's methods. This can be roughly summarized in the following diagram.

<figure>
  <img src="readable-stream.svg" width="670" alt="The readable stream state machine diagram." />

  <figcaption>
    <dl>
      <dt><span style="font-style: normal; font-weight: normal; font-family: monospace;">monospace</span></dt>
      <dd>Methods of the stream</dd>

      <dt><span style="font-style: normal; font-weight: bold;">bold</span></dt>
      <dd>Constructor parameters</dd>

      <dt><span style="font-style: italic; font-weight: normal;">italic</span></dt>
      <dd>Capabilities given to constructor parameters</dd>
    </dl>
  </figcaption>
</figure>


<h3 id="rs-class">Class <code>ReadableStream</code></h3>

<h4 id="rs-class-definition">Class Definition</h4>

<em>This section is non-normative.</em>

If one were to write the <code>ReadableStream</code> class in something close to the syntax of [[!ECMASCRIPT]], it
would look like

<pre><code class="lang-javascript">
  class ReadableStream {
    constructor({
      start = (enqueue, close, error) => {},
      pull = (enqueue, close, error) => {},
      cancel = (reason) => {},
      strategy = %DefaultReadableStreamStrategy%
    } = {})

    get closed()
    get ready()
    get state()

    cancel(reason)
    pipeThrough({ writable, readable }, options)
    pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
    read()
  }
</code></pre>

<h4 id="rs-internal-slots">Internal Slots</h4>

Instances of <code>ReadableStream</code> are created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[close]]
    <td>A <a>Readable Stream Close Function</a> created with the ability to close this stream
  </tr>
  <tr>
    <td>\[[closedPromise]]
    <td>A promise that becomes fulfilled when the stream becomes <code>"closed"</code>; returned by the
      <code>closed</code> getter
  </tr>
  <tr>
    <td>\[[draining]]
    <td>A boolean flag indicating whether the stream has been closed, but still has chunks in its internal queue that
      have not yet been read
  </tr>
  <tr>
    <td>\[[enqueue]]
    <td>A <a>Readable Stream Enqueue Function</a> created with the ability to enqueue a passed <a>chunk</a> in this
      stream
  </tr>
  <tr>
    <td>\[[error]]
    <td>A <a>Readable Stream Error Function</a> created with the ability to move this stream to an
      <code>"errored"</code> state
  </tr>
  <tr>
    <td>\[[onCancel]]
    <td>A function passed to the constructor, meant to clean up and release access to the <a>underlying source</a>
  </tr>
  <tr>
    <td>\[[onPull]]
    <td>A function passed to the constructor, meant to pull more data from the <a>underlying source</a>
  </tr>
  <tr>
    <td>\[[pulling]]
    <td>A boolean flag indicating whether data is currently being pulled from the underlying sink
  </tr>
  <tr>
    <td>\[[queue]]
    <td>A List representing the stream's internal queue of <a>chunks</a>
  </tr>
  <tr>
    <td>\[[started]]
    <td>A boolean flag indicating whether the <a>underlying source</a> has finished starting
  </tr>
  <tr>
    <td>\[[state]]
    <td>A string containing the stream's current state; returned by the <code>state</code> getter
  </tr>
  <tr>
    <td>\[[storedError]]
    <td>A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate
      on the stream while in the <code>"errored"</code> state
  </tr>
  <tr>
    <td>\[[strategy]]
    <td>An object containing the stream's <a>queuing strategy</a>
  </tr>
  <tr>
    <td>\[[readyPromise]]
    <td>A promise that becomes fulfilled when the stream becomes <code>"readable"</code>, and is replaced with a new
      pending promise when the stream becomes <code>"waiting"</code>; returned by the <code>ready</code> getter
  </tr>
</table>

<h4 id="rs-constructor">new ReadableStream({ start, pull, cancel, strategy } = {})</h4>

<div class="note">
  The constructor is passed several functions, all optional, which govern how the constructed stream instance behaves:

  <ul>
    <li> <var>start</var>(<var>enqueue</var>, <var>close</var>, <var>error</var>) is called immediately, and is
      typically used to adapt a <a>push source</a> by setting up relevant event listeners, or to acquire access to a
      <a>pull source</a>. If this process is asynchronous, it can return a promise to signal success or failure.
    <li> <var>pull</var>(<var>enqueue</var>, <var>close</var>, <var>error</var>) is called when the stream's internal
      queue of chunks is depleted, and the consumer has signaled that they wish to consume more data. Once it is
      called, it will not be called again until the passed <var>enqueue</var> callback is called.
    <li> <var>cancel</var>(<var>reason</var>) is called when the consumer signals that they are no longer interested
      in the stream. It should perform any actions necessary to release access to the <a>underlying source</a>. If this
      process is asynchronous, it can return a promise to signal success or failure.
  </ul>

  Both <var>start</var> and <var>pull</var> are given the ability to manipulate the stream's internal queue and state
  via the passed <var>enqueue</var>, <var>close</var>, and <var>error</var> callbacks. This is an example of the
  <a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/">revealing constructor pattern</a>.
</div>

<ol>
  <li> If <var>start</var> is <b>undefined</b>, set <var>start</var> to a no-op function.
  <li> If IsCallable(<var>start</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>pull</var> is <b>undefined</b>, set <var>pull</var> to a no-op function.
  <li> If IsCallable(<var>pull</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>cancel</var> is <b>undefined</b>, set <var>cancel</var> to a no-op function.
  <li> If IsCallable(<var>cancel</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>strategy</var> is <b>undefined</b>, set <var>strategy</var> to %DefaultReadableStreamStrategy%.
  <li> Set <b>this</b>@\[[onPull]] to <var>pull</var>.
  <li> Set <b>this</b>@\[[onCancel]] to <var>cancel</var>.
  <li> Set <b>this</b>@\[[strategy]] to <var>strategy</var>.
  <li> Set <b>this</b>@\[[readyPromise]] and <b>this</b>@\[[closedPromise]] to new promises.
  <li> Set <b>this</b>@\[[queue]] to a new empty List.
  <li> Set <b>this</b>@\[[state]] to <code>"waiting"</code>.
  <li> Set <b>this</b>@\[[started]], <b>this</b>@\[[draining]], and <b>this</b>@\[[pulling]] to <b>false</b>.
  <li> Set <b>this</b>@\[[enqueue]] to CreateReadableStreamEnqueueFunction(<b>this</b>).
  <li> Set <b>this</b>@\[[close]] to CreateReadableStreamCloseFunction(<b>this</b>).
  <li> Set <b>this</b>@\[[error]] to CreateReadableStreamErrorFunction(<b>this</b>).
  <li> Let <var>startResult</var> be the result of calling <var>start</var>(<b>this</b>@\[[enqueue]],
    <b>this</b>@\[[close]], <b>this</b>@\[[error]]).
  <li> ReturnIfAbrupt(<var>startResult</var>).
  <li> Resolve <var>startResult</var> as a promise:
    <ol>
      <li> Upon fulfillment,
        <ol>
          <li> Set <b>this</b>@\[[started]] to <b>true</b>.
          <li> Return CallReadableStreamPull(<b>this</b>).
        </ol>
      <li> Upon rejection with reason <var>r</var>, call-with-rethrow <b>this</b>@\[[error]](<var>r</var>).
    </ol>
</ol>

<h4 id="rs-prototype">Properties of the <code>ReadableStream</code> Prototype</h4>

<h5 id="rs-closed">get closed</h5>

<div class="note">
  The <code>closed</code> getter returns a promise that will be fulfilled when the stream becomes closed, or rejected
  if it ever errors.
</div>

<ol>
  <li> Return <b>this</b>@\[[closedPromise]].
</ol>

<h5 id="rs-ready">get ready</h5>

<div class="note">
  The <code>ready</code> getter returns a promise that will be fulfilled either when the stream's internal queue becomes
  nonempty, or the stream becomes closed. (The promise will be rejected if the stream errors.)
</div>

<ol>
  <li> Return <b>this</b>@\[[readyPromise]].
</ol>

<h5 id="rs-state">get state</h5>

<div class="note">
  The <code>state</code> getter returns the state of the stream, which will be one of the following:

  <dl>
    <dt><code>"waiting"</code>
    <dd>The stream's internal queue is empty; use <code>.ready</code> to be notified of any changes.

    <dt><code>"readable"</code>
    <dd>The stream's internal queue has <a>chunks</a> available; call <code>.read()</code> to retrieve the next one.

    <dt><code>"closed"</code>
    <dd>All data has been successfully read from the stream, and no more is available.

    <dt><code>"errored"</code>
    <dd>An error occurred interacting with the <a>underlying source</a>, and so the stream is now dead.
  </dl>
</div>

<ol>
  <li> Return <b>this</b>@\[[state]].
</ol>

<h5 id="rs-cancel">cancel(reason)</h5>

<div class="note">
  The <code>cancel</code> method signals a loss of interest in the stream by a consumer. Calling it will immediately
  move the stream to a <code>"closed"</code> state, throwing away any queued data, as well as executing any
  cancellation mechanism of the <a>underlying source</a>.
</div>

<ol>
  <li> If <b>this</b>@\[[state]] is <code>"closed"</code>, return a new promise resolved with <b>undefined</b>.
  <li> If <b>this</b>@\[[state]] is <code>"errored"</code>, return a new promise rejected with <b>this</b>@\[[storedError]].
  <li> If <b>this</b>@\[[state]] is <code>"waiting"</code>, resolve <b>this</b>@\[[readyPromise]] with <b>undefined</b>.
  <li> Let <b>this</b>@\[[queue]] be a new empty List.
  <li> Set <b>this</b>@\[[state]] to <code>"closed"</code>.
  <li> Resolve <b>this</b>@\[[closedPromise]] with <b>undefined</b>.
  <li> Let <var>sourceCancelPromise</var> be the result of promise-calling <b>this</b>@\[[onCancel]](<var>reason</var>).
  <li> Return the result of transforming <var>sourceCancelPromise</var> by a fulfillment handler that returns <b>undefined</b>.
</ol>

<h5 id="rs-pipe-through">pipeThrough({ writable, readable }, options)</h5>

<div class="note">
  The <code>pipeThrough</code> method provides a convenient, chainable way of <a>piping</a> a <a>readable stream</a>
  through a <a>transform stream</a> (or any other <code>{ writable, readable }</code> pair). It simply pipes the stream
  into the writable side of the supplied pair, and returns the readable side for further use.
</div>

<div class="example">
  A typical example of constructing <a>pipe chain</a> using <code>pipeThrough</code> would look like

  <pre><code class="lang-javascript">
    httpResponseBody
      .pipeThrough(decompressorTransform)
      .pipeThrough(ignoreNonImageFilesTransform)
      .pipeTo(mediaGallery);
  </code></pre>
</div>

<ol>
  <li> If Type(<var>writable</var>) is not Object, then throw a <b>TypeError</b> exception.
  <li> If Type(<var>readable</var>) is not Object, then throw a <b>TypeError</b> exception.
  <li> Call-with-rethrow Invoke(<b>this</b>, <code>"pipeTo"</code>, (<var>writable</var>, <var>options</var>)).
  <li> Return <var>readable</var>.
</ol>

<h5 id="rs-pipe-to">pipeTo(dest, options)</h5>

The <code>pipeTo</code> method is one of the more complex methods, and is undergoing some revision and edge-case
bulletproofing before we write it up in prose.

For now, please consider the reference implementation normative:
<a href="https://github.com/whatwg/streams/blob/master/reference-implementation/lib/readable-stream.js">reference-implementation/lib/readable-stream.js</a>,
look for the <code>pipeTo</code> method.

<h5 id="rs-read">read()</h5>

<div class="note">
  The <code>read</code> method will return the next <a>chunk</a> from the stream's internal queue, if available. If
  this causes the queue to become empty, more data will be pulled from the <a>underlying source</a>.
</div>

<ol>
  <li> If <b>this</b>@\[[state]] is <code>"waiting"</code> or <code>"closed"</code>, throw a <b>TypeError</b> exception.
  <li> If <b>this</b>@\[[state]] is <code>"errored"</code>, throw <b>this</b>@\[[storedError]].
  <li> Assert: <b>this</b>@\[[state]] is <code>"readable"</code>.
  <li> Assert: <b>this</b>@\[[queue]] is not empty.
  <li> Let <var>chunk</var> be DequeueValue(<b>this</b>@\[[queue]]).
  <li> If <b>this</b>@\[[queue]] is now empty,
    <ol>
      <li> If <b>this</b>@\[[draining]] is <b>true</b>,
        <ol>
          <li> Set <b>this</b>@\[[state]] to <code>"closed"</code>.
          <li> Resolve <b>this</b>@\[[closedPromise]] with <b>undefined</b>.
        </ol>
      <li> If <b>this</b>@\[[draining]] is <b>false</b>,
        <ol>
          <li> Set <b>this</b>@\[[state]] to <code>"waiting"</code>.
          <li> Let <b>this</b>@\[[readyPromise]] be a new promise.
        </ol>
    </ol>
  <li> Call-with-rethrow CallReadableStreamPull(<b>this</b>).
  <li> Return <var>chunk</var>.
</ol>

<h3 id="rs-abstract-ops">Readable Stream Abstract Operations</h3>

<h4 id="call-readable-stream-pull">CallReadableStreamPull ( stream )</h4>

<ol>
  <li> If <var>stream</var>@\[[pulling]] is <b>true</b> or <var>stream</var>@\[[draining]] is <b>true</b> or
    <var>stream</var>@\[[started]] is <b>false</b> or <var>stream</var>@\[[state]] is <code>"closed"</code> or
    <var>stream</var>@\[[state]] is <code>"errored"</code>, return <b>undefined</b>.
  <li> Let <var>shouldApplyBackpressure</var> be ShouldReadableStreamApplyBackpressure(<var>stream</var>).
  <li> If <var>shouldApplyBackpressure</var> is <b>true</b>, return <b>undefined</b>.
  <li> Set <var>stream</var>@\[[pulling]] to <b>true</b>.
  <li> Let <var>pullResult</var> be the result of calling <var>stream</var>@\[[onPull]](<var>stream</var>@\[[enqueue]],
    <var>stream</var>@\[[close]], <var>stream</var>@\[[error]]).
  <li> If <var>pullResult</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <var>stream</var>@\[[error]](<var>pullResult</var>.\[[value]]).
      <li> Return <var>pullResult</var>.
    </ol>
  <li> Otherwise, return <b>undefined</b>.
</ol>

<h4 id="create-readable-stream-close-function">CreateReadableStreamCloseFunction ( stream )</h4>

<ol>
  <li> Return a new <a>Readable Stream Close Function</a> closing over <var>stream</var>.
</ol>

A <dfn>Readable Stream Close Function</dfn> is a built-in anonymous function of zero arguments, closing over a variable
<var>stream</var>, that performs the following steps:

<ol>
  <li> If <var>stream</var>@\[[state]] is <code>"waiting"</code>,
    <ol>
      <li> Resolve <var>stream</var>@\[[readyPromise]] with <b>undefined</b>.
      <li> Resolve <var>stream</var>@\[[closedPromise]] with <b>undefined</b>.
      <li> Set <var>stream</var>@\[[state]] to <code>"closed"</code>.
    </ol>
  <li> If <var>stream</var>@\[[state]] is <code>"readable"</code>,
    <ol>
      <li> Set <var>stream</var>@\[[draining]] to <b>true</b>.
    </ol>
</ol>

<h4 id="create-readable-stream-enqueue-function">CreateReadableStreamEnqueueFunction ( stream )</h4>

<ol>
  <li> Return a new <a>Readable Stream Enqueue Function</a> closing over <var>stream</var>.
</ol>

A <dfn>Readable Stream Enqueue Function</dfn> is a built-in anonymous function of one argument <var>chunk</var>,
closing over a variable <var>stream</var>, that performs the following steps:

<ol>
  <li> If <var>stream</var>@\[[state]] is <code>"errored"</code>, throw <var>stream</var>@\[[storedError]].
  <li> If <var>stream</var>@\[[state]] is <code>"closed"</code>, throw a <b>TypeError</b> exception.
  <li> If <var>stream</var>@\[[draining]] is <b>true</b>, throw a <b>TypeError</b> exception.
  <li> Let <var>chunkSize</var> be Invoke(<var>stream</var>@\[[strategy]], <code>"size"</code>, (<var>chunk</var>)).
  <li> If <var>chunkSize</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <var>stream</var>@\[[error]](<var>chunkSize</var>.\[[value]]).
      <li> Return <var>chunkSize</var>.
    </ol>
  <li>Call-with-rethrow EnqueueValueWithSize(<var>stream</var>@\[[queue]], <var>chunk</var>,
    <var>chunkSize</var>.\[[value]]).
  <li> Set <var>stream</var>@\[[pulling]] to <b>false</b>.
  <li> Let <var>shouldApplyBackpressure</var> be ShouldReadableStreamApplyBackpressure(<var>stream</var>).
  <li> If <var>stream</var>@\[[state]] is <code>"waiting"</code>,
    <ol>
      <li> Set <var>stream</var>@\[[state]] to <code>"readable"</code>.
      <li> Resolve <var>stream</var>@\[[readyPromise]] with <b>undefined</b>.
    </ol>
  <li> If <var>shouldApplyBackpressure</var>.\[[value]] is <b>true</b>, return <b>false</b>.
  <li> Return <b>true</b>.
</ol>

<h4 id="create-readable-stream-error-function">CreateReadableStreamErrorFunction ( stream )</h4>

<ol>
  <li> Return a new <a>Readable Stream Error Function</a> closing over <var>stream</var>.
</ol>

A <dfn>Readable Stream Error Function</dfn> is a built-in anonymous function of one argument <var>e</var>, closing over
a variable <var>stream</var>, that performs the following steps:

<ol>
  <li> If <var>stream</var>@\[[state]] is <code>"waiting"</code>,
    <ol>
      <li> Set <var>stream</var>@\[[state]] to <code>"errored"</code>.
      <li> Set <var>stream</var>@\[[storedError]] to <var>e</var>.
      <li> Reject <var>stream</var>@\[[readyPromise]] with <var>e</var>.
      <li> Reject <var>stream</var>@\[[closedPromise]] with <var>e</var>.
    </ol>
  <li> If <var>stream</var>@\[[state]] is <code>"readable"</code>,
    <ol>
      <li> Let <var>stream</var>@\[[queue]] be a new empty List.
      <li> Set <var>stream</var>@\[[state]] to <code>"errored"</code>.
      <li> Set <var>stream</var>@\[[storedError]] to <var>e</var>.
      <li> Let <var>stream</var>@\[[readyPromise]] be a new promise rejected with <var>e</var>.
      <li> Reject <var>stream</var>@\[[closedPromise]] with <var>e</var>.
    </ol>
</ol>

<h4 id="should-readable-stream-apply-backpressure">ShouldReadableStreamApplyBackpressure ( stream )</h4>

<ol>
  <li> Let <var>queueSize</var> be GetTotalQueueSize(<var>stream</var>@\[[queue]]).
  <li> ReturnIfAbrupt(<var>queueSize</var>).
  <li> Let <var>shouldApplyBackpressure</var> be ToBoolean(Invoke(<var>stream</var>@\[[strategy]],
    <code>"shouldApplyBackpressure"</code>, (<var>queueSize</var>))).
  <li> If <var>shouldApplyBackpressure</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <var>stream</var>@\[[error]](<var>shouldApplyBackpressure</var>.\[[value]]).
      <li> Return <var>shouldApplyBackpressure</var>.
    </ol>
  <li> Otherwise, return <var>shouldApplyBackpressure</var>.\[[value]].
</ol>

<h3 id="default-rs-strategy">%DefaultReadableStreamStrategy%</h3>

%DefaultReadableStreamStrategy% is a well-known intrinsic object representing the default <a>queuing strategy</a> for
<a>readable streams</a>. It has two methods.

<div class="note">
  The existence of an independent object for the default readable stream queuing strategy is not actually observable.
  Thus, implementations could implement this default strategy by other means, e.g. by incorporating the default logic
  into the readable stream algorithms themselves.
</div>

<h4 id="default-rs-strategy-should-apply-backpressure">shouldApplyBackpressure(queueSize)</h4>

<ol>
  <li> Assert: <var>queueSize</var> is a non-<b>NaN</b> number.</li>
  <li> Return <var>queueSize</var> > 1.
</ol>

<h4 id="default-rs-strategy-size">size()</h4>

<ol>
  <li> Return 1.
</ol>

<h2 id="ws">Writable Streams</h2>

<h3 id="ws-intro">Introduction to Writable Streams</h3>

<em>This section is non-normative.</em>

The writable stream API allows wrapping of <a>underlying sinks</a> into an object on which two fundamental operations
can be performed: <a>chunks</a> can be written to the stream, and the stream can be closed.

The writable stream implementation is designed to encapsulate the potential complexity of the <a>underlying sink</a>
from users of the stream API. In particular, users of a stream object can write chunks to the stream at any pace,
without regard for whether previous writes have completed or succeeded. It is the job of the stream implementation to
ensure that writes are forwarded to the <a>underlying sink</a> in order, and only after successful completion of
previous writes. This allows seamless use of the writable stream even in cases such as piping a fast readable file
stream to a slower writable network socket stream, which cannot acknowledge the incoming data at the same rate it
becomes available.

<div class="example">
  The following function wraps a web socket [[HTML]] as the <a>underlying sink</a> of a new writable stream. Web
  sockets do not provide any way to tell when a given chunk of data has been successfully sent, so this writable stream
  has no ability to communicate backpressure signals to any users: it will always be in the <code>"writable"</code>
  state.

  <pre><code class="lang-javascript">
    function makeWritableWebSocketStream(url, protocols) {
      const ws = new WebSocket(url, protocols);

      return new WritableStream({
        start(error) {
          ws.onerror = error;
          return new Promise(resolve => ws.onopen = resolve);
        },

        write(chunk) {
          ws.send(chunk);
          // Return immediately, since the web socket gives us no way to tell
          // when the write completes.
        },

        close() {
          return new Promise((resolve, reject) => {
            ws.onclose = resolve;
            ws.close();
          });
        }
      });
    }
  </code></pre>
</div>

<div class="example">
  The following function wraps an <a>underlying sink</a>, represented as a hypothetical "raw file handle," which
  provides methods for opening, writing to, and closing itself. Notably, the raw file handle's <code>write</code> method
  calls back to signal when writes are complete, which allows the stream to correctly communicate backpressure signals
  to any users by setting its state to <code>"waiting"</code> instead of <code>"writable"</code> when the queue gets too
  full. Allow of the raw file handle's methods can call their callbacks either synchronously or asynchronously—a
  <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">Zalgo-releasing</a> horror which we can
  hide from our users by wrapping them in a writable stream.

  <pre><code class="lang-javascript">
    function makeWritableFileStream(filename) {
      const fileHandle = createRawFileHandle(filename, "w");

      return new WritableStream({
        start() {
          return new Promise((resolve, reject) => {
            fileHandle.open(err => {
              if (err) {
                reject(err);
              }
              resolve();
            });
          });
        },

        write(chunk) {
          return new Promise((resolve, reject) => {
            fileHandle.write(chunk, writeErr => {
              if (writeErr) {
                // If trying to write results in an error, (attempt to) close the
                // underlying file handle; we're not going to write any more.
                fileHandle.close(closeErr => {
                  // If *closing* errors, pass along that error to the stream.
                  if (closeErr) {
                    reject(closeErr);
                  }

                  // Otherwise, if closing succeeds, pass along the write error.
                  reject(writeErr);
                });
              } else {
                // If there's no error, then signal that this write completed.
                resolve();
              }
            });
          });
        },

        close() {
          return new Promise((resolve, reject) => {
            fileHandle.close(err => {
              if (err) {
                reject(err);
              }
              resolve();
            });
          });
        }
      });
    }
  </code></pre>

  We can then use this function to create a writable stream for a file, and then pipe a readable stream to it:

  <pre><code class="lang-javascript">
    var fileStream = makeWritableFileStream("/example/path/on/fs.txt");

    readableStream.pipeTo(fileStream)
      .then(() => console.log("All data successfully written!"))
      .catch(e => console.error("Something went wrong!", e));
  </code></pre>

  Note that if a particular call to <code>fileHandle.write</code> takes a longer time, <code>done</code> will be
  called later. In the meantime, additional writes can be queued up, which are stored in the stream's internal queue.
  The accumulation of this queue can move the stream into a <code>"waiting"</code> state, which is a signal to users
  of the stream that they should back off and stop writing if possible.
</div>

<div class="example">
  Although writable streams will usually be used by piping to them from a readable stream, you can also write to them
  directly. Since they queue any incoming writes, and take care internally to forward them to the <a>underlying sink</a>
  in sequence, you can indiscriminately write to a writable stream without much ceremony:

  <pre><code class="lang-javascript">
    function writeArrayToStream(array, writableStream) {
      array.forEach(chunk => writableStream.write(chunk));

      return writableStream.close();
    }

    writeArrayToStream([1, 2, 3, 4, 5], writableStream)
      .then(() => console.log("All done!"))
      .catch(e => console.error("Error with the stream: " + e));
  </code></pre>
</div>

<h3 id="ws-state-diagram">The Writable Stream State Diagram</h3>

<em>This section is non-normative.</em>

TODO

<h3 id="ws-class">Class <code>WritableStream</code></h3>

<h4 id="ws-class-definition">Class Definition</h4>

<em>This section is non-normative.</em>

If one were to write the <code>WritableStream</code> class in something close to the syntax of [[!ECMASCRIPT]], it
would look like


<pre><code class="lang-javascript">
  class WritableStream {
    constructor({
      start = (error) => {},
      write = (chunk) => {},
      close = () => {},
      abort = (reason) => close(),
      strategy = %DefaultWritableStreamStrategy%
    } = {})

    get closed()
    get ready()
    get state()

    abort(reason)
    close()
    write(chunk)
  }
</code></pre>

<h4 id="ws-internal-slots">Internal Slots</h4>

Instances of <code>WritableStream</code> are created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[closedPromise]]
    <td>A promise that becomes fulfilled when the stream becomes <code>"closed"</code>; returned by the
      <code>closed</code> getter
  </tr>
  <tr>
    <td>\[[onAbort]]
    <td>A function passed to the constructor, meant to abruptly clean up and release access to the <a>underlying
      sink</a>
  </tr>
  <tr>
    <td>\[[onClose]]
    <td>A function passed to the constructor, meant to close the the <a>underlying sink</a>
  </tr>
  <tr>
    <td>\[[onWrite]]
    <td>A function passed to the constructor, meant to write to the <a>underlying sink</a>
  </tr>
  <tr>
    <td>\[[error]]
    <td>A <a>Writable Stream Error Function</a> created with the ability to move this stream to an
      <code>"errored"</code> state
  </tr>
  <tr>
    <td>\[[queue]]
    <td>A List representing the stream's internal queue of pending writes
  </tr>
  <tr>
    <td>\[[started]]
    <td>A boolean flag indicating whether the <a>underlying sink</a> has finished starting
  </tr>
  <tr>
    <td>\[[startedPromise]]
    <td>A promise storing the result of starting the <a>underlying sink</a>, used to delay actions until that is
      complete
  </tr>
  <tr>
    <td>\[[state]]
    <td>A string containing the stream's current state; returned by the <code>state</code> getter
  </tr>
  <tr>
    <td>\[[storedError]]
    <td>A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate
      on the stream while in the <code>"errored"</code> state
  </tr>
  <tr>
    <td>\[[strategy]]
    <td>An object containing the stream's <a>queuing strategy</a>
  </tr>
  <tr>
    <td>\[[readyPromise]]
    <td>A promise that becomes fulfilled when the stream becomes <code>"writable"</code>, and is replaced with a new
      pending promise when the stream becomes <code>"waiting"</code>; returned by the <code>ready</code> getter
  </tr>
  <tr>
    <td>\[[writing]]
    <td>A boolean flag indicating whether the stream is currently writing to the <a>underlying sink</a>, used to
      prevent concurrent such writes
  </tr>
</table>

<h4 id="ws-constructor">new WritableStream({ start, write, close, abort, strategy } = {})</h4>

<div class="note">
  The constructor is passed several functions, all optional, which govern how the constructed stream instance behaves:

  <ul>
    <li> <var>start</var>(<var>error</var>) is called immediately, and should perform any actions necessary to acquire
      access to the <a>underlying sink</a>. If this process is asynchronous, it can return a promise to signal success
      or failure.
    <li> <var>write</var>(<var>chunk</var>) is called when a new <a>chunk</a> of data is ready to be written to the
      <a>underlying sink</a>. It can return a promise to signal success or failure of the write operation. The stream
      implementation guarantees that this function will be called only after previous writes have succeeded, and never
      after <var>close</var> or <var>abort</var> is called.
    <li> <var>close</var>() is called after the producer signals that they are done writing chunks to the stream, and
      all queued-up writes successfully complete. It should perform any actions necessary to finalize writes to the
      <a>underlying sink</a>, and release access to it. If this process is asynchronous, it can return a promise to
      signal success or failure. The stream implementation guarantees that this function will be called only after all
      queued-up writes have succeeded.
    <li> <var>abort</var>(<var>reason</var>) is called when the producer signals they wish to abruptly close the stream
      and put it in an <code>"errored"</code> state. It should clean up any held resources, much like <var>close</var>,
      but perhaps with some custom handling. Unlike <var>close</var>, <var>abort</var> will be called even if writes
      are queued up; those <a>chunks</a> will be thrown away. If this process is asynchronous, it can return a promise
      to signal success or failure. If no abort function is passed, by default the <var>close</var> function will be
      called instead.
  </ul>
</div>

<div class="note">
  Due to the way writable streams asynchronously close, it is possible for both <var>close</var> and <var>abort</var>
  to be called, in cases where the <a>producer</a> aborts the stream while it is in the <code>"closing"</code> state.
  Notably, since a stream always spends at least one turn in the <code>"closing"</code> state, code like
  <code>ws.close(); ws.abort(...);</code> will cause both to be called, even if the <var>close</var> function itself
  has no asynchronous behavior. A well-designed <a>underlying source</a> should be able to deal with this.
</div>

<ol>
  <li> If <var>start</var> is <b>undefined</b>, set <var>start</var> to a no-op function.
  <li> If IsCallable(<var>start</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>write</var> is <b>undefined</b>, set <var>write</var> to a no-op function.
  <li> If IsCallable(<var>write</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>close</var> is <b>undefined</b>, set <var>close</var> to a no-op function.
  <li> If IsCallable(<var>close</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>abort</var> is <b>undefined</b>, set <var>abort</var> to <var>close</var>.
  <li> If IsCallable(<var>abort</var>) is <b>false</b>, throw a <b>TypeError</b> exception.
  <li> If <var>strategy</var> is <b>undefined</b>, set <var>strategy</var> to %DefaultWritableStreamStrategy%.
  <li> Set <b>this</b>@\[[onWrite]] to <var>write</var>.
  <li> Set <b>this</b>@\[[onClose]] to <var>onClose</var>.
  <li> Set <b>this</b>@\[[onAbort]] to <var>abort</var>.
  <li> Set <b>this</b>@\[[strategy]] to <var>strategy</var>.
  <li> Set <b>this</b>@\[[closedPromise]] to a new promise.
  <li> Set <b>this</b>@\[[readyPromise]] to a new promise resolved with <b>undefined</b>.
  <li> Set <b>this</b>@\[[queue]] to a new empty List.
  <li> Set <b>this</b>@\[[state]] to <code>"writable"</code>.
  <li> Set <b>this</b>@\[[started]] and <b>this</b>@\[[writing]] to <b>false</b>.
  <li> Set <b>this</b>@\[[error]] to CreateWritableStreamErrorFunction(<b>this</b>).
  <li> Call-with-rethrow SyncWritableStreamStateWithQueue(<b>this</b>).
  <li> Let <var>startResult</var> be the result calling <var>start</var>(<b>this</b>@\[[error]]).
  <li> ReturnIfAbrupt(<var>startResult</var>).
  <li> Set <b>this</b>@\[[startedPromise]] to the result of resolving <var>startResult</var> as a promise.
    <ol>
      <li> Upon fulfillment,
        <ol>
          <li> Set <b>this</b>@\[[started]] to <b>true</b>.
          <li> Set <b>this</b>@\[[startedPromise]] to <b>undefined</b>.
        </ol>
      <li> Upon rejection with reason <var>r</var>, call-with-rethrow <b>this</b>@\[[error]](<var>r</var>).
    </ol>
</ol>

<h4 id="ws-prototype">Properties of the <code>WritableStream</code> Prototype</h4>

<h5 id="ws-closed">get closed</h5>

<div class="note">
  The <code>closed</code> getter returns a promise that will be fulfilled when the stream becomes closed, or rejected
  if it ever errors.
</div>

<ol>
  <li> Return <b>this</b>@\[[closedPromise]].
</ol>

<h5 id="ws-ready">get ready</h5>

<div class="note">
  The <code>ready</code> getter returns a promise that will be fulfilled when the stream enters the
  <code>"writable"</code> state, i.e., when the stream's internal queue is not full according to its <a>queuing
  strategy</a>. (The promise will be rejected if the stream errors.)

  In essence, this promise gives a signal as to when any backpressure has let up.
</div>

<ol>
  <li> Return <b>this</b>@\[[readyPromise]].
</ol>

<h5 id="ws-state">get state</h5>

<div class="note">
  The <code>state</code> getter returns the state of the stream, which will be one of the following:

  <dl>
    <dt><code>"waiting"</code>
    <dd>The stream's internal queue is full; that is, the stream is
      exerting <a>backpressure</a>. Use <code>.ready</code> to be notified of when the pressure subsides.

    <dt><code>"writable"</code>
    <dd>The stream's internal queue is not full; call <code>.write()</code> until backpressure is exerted.

    <dt><code>"closing"</code>
    <dd>The stream's <code>.close()</code> method has been called, and a command to close is in the queue or
      being processed by the <a>underlying sink</a>; attempts to write will now fail.

    <dt><code>"closed"</code>
    <dd>The <a>underlying sink</a> has been closed; writing is no longer possible.

    <dt><code>"errored"</code>
    <dd>An error occurred interacting with the <a>underlying sink</a> or the stream has been aborted, so the stream is
      now dead.
  </dl>
</div>

<ol>
  <li> Return <b>this</b>@\[[state]].
</ol>

<h5 id="ws-abort">abort(reason)</h5>

<div class="note">
  The <code>abort</code> method signals that the producer can no longer successfully write to the stream and it should
  be immediately moved to an <code>"errored"</code> state, with any queued-up writes discarded. This will also execute
  any abort mechanism of the <a>underlying sink</a>.
</div>

<ol>
  <li> If <b>this</b>@\[[state]] is <code>"closed"</code>, return a new promise resolved with <b>undefined</b>.
  <li> If <b>this</b>@\[[state]] is <code>"errored"</code>, return a new promise rejected with
    <b>this</b>@\[[storedError]].
  <li> Call-with-rethrow <b>this</b>@\[[error]](reason).
  <li> Let <var>sinkAbortPromise</var> be the result of promise-calling <b>this</b>\[[onAbort]](<var>reason</var>).
  <li> Return the result of transforming <var>sinkAbortPromise</var> by a fulfillment handler that returns <b>undefined</b>.
</ol>

<h5 id="ws-close">close()</h5>

<div class="note">
  The <code>close</code> method signals that the producer is done writing chunks to the stream and wishes to move the
  stream to a <code>"closed"</code> state. This queues an action to close the stream, such that once any currently
  queued-up writes complete, the close mechanism of the <a>underlying sink</a> will execute, releasing any held
  resources. In the meantime, the stream will be in a <code>"closing"</code> state.
</div>

<ol>
  <li> If <b>this</b>@\[[state]] is <code>"closing"</code> or <code>"closed"</code>, return a promise rejected with a
    <b>TypeError</b> exception.
  <li> If <b>this</b>@\[[state]] is <code>"errored"</code>, return a promise rejected with
    <b>this</b>@\[[storedError]].
  <li> If <b>this</b>@\[[state]] is <code>"writable"</code>, set <b>this</b>@\[[readyPromise]] to a new promise
    rejected with a <b>TypeError</b> exception.
  <li> If <b>this</b>@\[[state]] is <code>"waiting"</code>, reject <b>this</b>@\[[readyPromise]] with a
    <b>TypeError</b> exception.
  <li> Set <b>this</b>@\[[state]] to <code>"closing"</code>
  <li> Call-with-rethrow EnqueueValueWithSize(<b>this</b>@\[[queue]], <code>"close"</code>, <b>0</b>).
  <li> Call-with-rethrow CallOrScheduleWritableStreamAdvanceQueue(<b>this</b>).
  <li>Return <b>this</b>@\[[closedPromise]].
</ol>

<h5 id="ws-write">write(chunk)</h5>

<div class="note">
  The <code>write</code> method adds a write to the stream's internal queue, instructing the stream to
  write the given <a>chunk</a> of data to the <a>underlying sink</a> once all other pending writes have finished
  successfully. It returns a promise that will be fulfilled or rejected depending on the success or failure of writing
  the chunk to the underlying sink.

  The impact of enqueuing this chunk will be immediately reflected in the stream's <code>state</code> property; in
  particular, if the internal queue is now full according to the stream's <a>queuing strategy</a>, the stream will
  exert backpressure by changing its state to <code>"waiting"</code>.
</div>

<ol>
  <li>If <b>this</b>@\[[state]] is <code>"closing"</code> or <code>"closed"</code>, return a promise rejected with a
    <b>TypeError</b>.
  <li> If <b>this</b>@\[[state]] is <code>"errored"</code>, return a promise rejected with
    <b>this</b>@\[[storedError]].
  <li> Assert: <b>this</b>\[[state]] is either <code>"waiting"</code> or <code>"writable"</code>.
  <li> Let <var>chunkSize</var> be Invoke(<b>this</b>@\[[strategy]], <code>"size"</code>, (<var>chunk</var>)).
  <li> If <var>chunkSize</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <b>this</b>@\[[error]](<var>chunkSize</var>.\[[value]]).
      <li> Return a new promise rejected with <var>chunkSize</var>.\[[value]].
    </ol>
  </li>
  <li> Set <var>chunkSize</var> to <var>chunkSize</var>.\[[value]].
  <li> Let <var>promise</var> be a new promise.
  <li> Let <var>writeRecord</var> be Record{\[[promise]]: <var>promise</var>, \[[chunk]]: <var>chunk</var>}.
  <li> Let <var>enqueueResult</var> be EnqueueValueWithSize(<b>this</b>@\[[queue]], <var>writeRecord</var>, <var>chunkSize</var>).
  <li> If <var>enqueueResult</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <b>this</b>@\[[error]](<var>enqueueResult</var>.\[[value]]).
      <li> Return a new promise rejected with <var>enqueueResult</var>.\[[value]].
    </ol>
  </li>
  <li> Let <var>syncResult</var> be SyncWritableStreamStateWithQueue(<b>this</b>).
  <li> If <var>syncResult</var> is an abrupt completion,
    <ol>
      <li> Call-with-rethrow <b>this</b>@\[[error]](<var>syncResult</var>.\[[value]]).
      <li> Return <var>promise</var>.
    </ol>
  </li>
  <li> Call-with-rethrow CallOrScheduleWritableStreamAdvanceQueue(<b>this</b>).
  <li> Return <var>promise</var>.
</ol>

<h3 id="ws-abstract-ops">Writable Stream Abstract Operations</h3>

<h4 id="call-or-schedule-writable-stream-advance-queue">CallOrScheduleWritableStreamAdvanceQueue ( stream )</h4>

<ol>
  <li> If <var>stream</var>@\[[started]] is <b>false</b>, then
    <ol>
      <li> Upon fulfillment of <var>stream</var>@\[[startedPromise]], call-with-rethrow
        WritableStreamAdvanceQueue(<var>stream</var>).
      <li> Return <b>undefined</b>.
    </ol>
  <li> Otherwise, return WritableStreamAdvanceQueue(<var>stream</var>).
</ol>

<h4 id="close-writable-stream">CloseWritableStream ( stream )</h4>

<ol>
  <li> Assert: <var>stream</var>@\[[state]] is <code>"closing"</code>.
  <li> Let <var>sinkClosePromise</var> be the result of promise-calling <var>stream</var>@\[[onClose]]().
    <ol>
      <li> Upon fulfillment,
        <ol>
          <li> If <var>stream</var>@\[[state]] is <code>"errored"</code>, return.
          <li> Assert: <var>stream</var>@\[[state]] is <code>"closing"</code>.
          <li> Resolve <var>stream</var>@\[[closedPromise]] with <b>undefined</b>.
          <li> Set <var>stream</var>@\[[state]] to <code>"closed"</code>.
        </ol>
      <li> Upon rejection with reason <var>r</var>, call-with-rethrow <var>stream</var>@\[[error]](<var>r</var>).
    </ol>
  <li> Return <b>undefined</b>.
</ol>

<h4 id="create-writable-stream-error-function">CreateWritableStreamErrorFunction ( stream )</h4>

<ol>
  <li> Return a new <a>Writable Stream Error Function</a> closing over <var>stream</var>.
</ol>

A <dfn>Writable Stream Error Function</dfn> is a built-in anonymous function of one argument <var>e</var>, closing over
a variable <var>stream</var>, that performs the following steps:

<ol>
  <li> If <var>stream</var>@\[[state]] is <code>"closed"</code> or <code>"errored"</code>, return <b>undefined</b>.
  <li> Repeat while <var>stream</var>@\[[queue]] is not empty:
    <ol>
      <li> Let <var>writeRecord</var> be DequeueValue(<var>stream</var>@\[[queue]]).
      <li> If <var>writeRecord</var> is not <code>"close"</code>, reject <var>writeRecord</var>.\[[promise]] with
        <var>e</var>.
    </ol>
  <li> Set <var>stream</var>@\[[storedError]] to <var>e</var>.
  <li> If <var>stream</var>@\[[state]] is <code>"writable"</code> or <code>"closing"</code>, set
    <var>stream</var>@\[[readyPromise]] to a new promise rejected with <var>e</var>.
  <li> If <var>stream</var>@\[[state]] is <code>"waiting"</code>, reject <var>stream</var>@\[[readyPromise]] with
    <var>e</var>.
  <li> Reject <var>stream</var>@\[[closedPromise]] with <var>e</var>.
  <li> Set <var>stream</var>@\[[state]] to <code>"errored"</code>.
</ol>

<h4 id="sync-writable-stream-state-with-queue">SyncWritableStreamStateWithQueue ( stream )</h4>

<ol>
  <li> If <var>stream</var>@\[[state]] is <code>"closing"</code>, return <b>undefined</b>.
  <li> Assert: <var>stream</var>@\[[state]] is either <code>"writable"</code> or <code>"waiting"</code>.
  <li> If <var>stream</var>@\[[state]] is <code>"waiting"</code> and <var>stream</var>@\[[queue]] is empty, then
    <ol>
      <li> Set <var>stream</var>@\[[state]] to <code>"writable"</code>.
      <li> Resolve <var>stream</var>@\[[readyPromise]] with <b>undefined</b>.
      <li> Return <b>undefined</b>.
    </ol>
  <li> Let <var>queueSize</var> be GetTotalQueueSize(<var>stream</var>@\[[queue]]).
  <li> ReturnIfAbrupt(<var>queueSize</var>).
  <li> Let <var>shouldApplyBackpressure</var> be ToBoolean(Invoke(<var>stream</var>@\[[strategy]],
    <code>"shouldApplyBackpressure"</code>, (<var>queueSize</var>))).
  <li> ReturnIfAbrupt(<var>shouldApplyBackpressure</var>).
  <li> If <var>shouldApplyBackpressure</var> is <b>true</b> and <var>stream</var>@\[[state]] is
    <code>"writable"</code>, then
    <ol>
      <li> Set <var>stream</var>@\[[state]] to <code>"waiting"</code>.
      <li> Set <var>stream</var>@\[[readyPromise]] to a new promise.
    </ol>
  <li> If <var>shouldApplyBackpressure</var> is <b>false</b> and <var>stream</var>@\[[state]] is
    <code>"waiting"</code>, then
    <ol>
      <li> Set <var>stream</var>@\[[state]] to <code>"writable"</code>.
      <li> Resolve <var>stream</var>@\[[readyPromise]] with <b>undefined</b>.
    </ol>
  <li> Return <b>undefined</b>.
</ol>

<h4 id="writable-stream-advance-queue">WritableStreamAdvanceQueue ( stream )</h4>

<ol>
  <li> If <var>stream</var>@\[[queue]] is empty, or <var>stream</var>@\[[writing]] is <b>true</b>, return
    <b>undefined</b>.
  <li> Let <var>writeRecord</var> be PeekQueueValue(<var>stream</var>@\[[queue]]).
  <li> If <var>writeRecord</var> is <code>"close"</code>, then
    <ol>
      <li> Assert: <var>stream</var>@\[[state]] is <code>"closing"</code>.
      <li> DequeueValue(<var>stream</var>@\[[queue]]).
      <li> Assert: <var>stream</var>@\[[queue]] is now empty.
      <li> Return CloseWritableStream(<var>stream</var>).
    </ol>
  <li> Set <var>stream</var>@\[[writing]] to <b>true</b>.
  <li> Promise-call <var>stream</var>@\[[onWrite]](<var>writeRecord</var>.\[[chunk]]).
    <ol>
      <li> Upon fulfillment,
        <ol>
          <li> If <var>stream</var>@\[[state]] is <code>"errored"</code>, return.
          <li> Set <var>stream</var>@\[[writing]] to <b>false</b>.
          <li> Resolve <var>writeRecord</var>.\[[promise]] with <b>undefined</b>.
          <li> DequeueValue(<var>stream</var>@\[[queue]]).
          <li> Let <var>syncResult</var> be SyncWritableStreamStateWithQueue(<var>stream</var>).
          <li> If <var>syncResult</var> is an abrupt completion, then call-with-rethrow
            <var>stream</var>@\[[error]](<var>syncResult</var>.\[[value]]).
          <li> Otherwise, return WritableStreamAdvanceQueue(<var>stream</var>).
        </ol>
      <li> Upon rejection with reason <var>r</var>, call-with-rethrow <var>stream</var>@\[[error]](<var>r</var>).
    </ol>
</ol>

<h3 id="default-ws-strategy">%DefaultWritableStreamStrategy%</h3>

%DefaultWritableStreamStrategy% is a well-known intrinsic object representing the default <a>queuing strategy</a> for
<a>writable streams</a>. It has two methods.

<div class="note">
  As with %DefaultReadableStreamStrategy%, this object is simply a spec device, and its existence is not observable.
</div>

<h4 id="default-ws-strategy-should-apply-backpressure">shouldApplyBackpressure(queueSize)</h4>

<ol>
  <li> Assert: <var>queueSize</var> is a non-<b>NaN</b> number.</li>
  <li> Return <var>queueSize</var> > 0.
</ol>

<h4 id="default-ws-strategy-size">size()</h4>

<ol>
  <li> Return 1.
</ol>

<h2 id="ts">Transform Streams</h2>

Transform streams have been developed in the testable implementation, but not yet re-encoded in spec language.
We are waiting to validate their design before doing so. In the meantime, see
<a href="https://github.com/whatwg/streams/blob/master/reference-implementation/lib/transform-stream.js">reference-implementation/lib/transform-stream.js</a>.


<h2 id="other-stuff">Other Stream APIs and Operations</h2>

<h3 id="blqs-class">Class <code>ByteLengthQueuingStrategy</code></h3>

A common <a>queuing strategy</a> when dealing with binary data is to wait until the accumulated <code>byteLength</code>
properties of the incoming chunks reaches a specified high-water mark. As such, this is provided as a built-in
<a>queuing strategy</a> that can be used when constructing streams.

<h4 id="blqs-class-definition">Class Definition</h4>

<em>This section is non-normative.</em>

If one were to write the <code>ByteLengthQueuingStrategy</code> class in something close to the syntax of
[[!ECMASCRIPT]], it would look like

<pre><code class="lang-javascript">
  class ByteLengthQueuingStrategy {
    constructor({ highWaterMark })
    shouldApplyBackpressure(queueSize)
    size(chunk)
  }
</code></pre>

<h4 id="blqs-internal-slots">Internal Slots</h4>

Instances of <code>ByteLengthQueuingStrategy</code> are created with the internal slots described in the following
table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[highWaterMark]]
    <td>A nonnegative number that determines when the strategy applies <a>backpressure</a>
  </tr>
</table>

<h4 id="blqs-constructor">new ByteLengthQueuingStrategy({ highWaterMark })</h4>

<div class="note">
  The constructor takes a nonnegative number for the high-water mark, and stores it for later use.
</div>

<ol>
  <li> Let <var>highWaterMark</var> be ToNumber(<var>highWaterMark</var>).
  <li> If <var>highWaterMark</var> is <b>NaN</b>, throw a <b>TypeError</b> exception.
  <li> If <var>highWaterMark</var> &lt; 0, throw a <b>RangeError</b> exception.
  <li> Set <b>this</b>@\[[highWaterMark]] to <var>highWaterMark</var>.
</ol>

<h4 id="blqs-prototype">Properties of the <code>ByteLengthQueuingStrategy</code> Prototype</h4>

<h5 id="blqs-should-apply-backpressure">shouldApplyBackpressure(queueSize)</h5>

<div class="note">
  The <code>shouldApplyBackpressure</code> method returns whether or not the given queue size is greater than the
  queuing strategy's high-water mark.
</div>

<ol>
  <li> Let <var>queueSize</var> be ToNumber(<var>queueSize</var>).
  <li> If <var>queueSize</var> is <b>NaN</b>, return <b>false</b>.
  <li> Return <var>queueSize</var> > <b>this</b>@\[[highWaterMark]].
</ol>

<h5 id="blqs-size">size(chunk)</h5>

<div class="note">
  The <code>size</code> method returns the given chunk's <code>byteLength</code> property. (If the chunk doesn't have
  one, it will return <b>undefined</b>, causing the stream using this strategy to error.)
</div>

<ol>
  <li> Return Get(<var>chunk</var>, <code>"byteLength"</code>).
</ol>

<h3 id="cqs-class">Class <code>CountQueuingStrategy</code></h3>

A common <a>queuing strategy</a> when dealing with streams of generic objects is to simply count the number of chunks
that have been accumulated so far, waiting until this number reaches a specified high-water mark. As such, this
strategy is also provided out of the box.

<h4 id="cqs-class-definition">Class Definition</h4>

<em>This section is non-normative.</em>

If one were to write the <code>CountQueuingStrategy</code> class in something close to the syntax of [[!ECMASCRIPT]],
it would look like

<pre><code class="lang-javascript">
  class CountQueuingStrategy {
    constructor({ highWaterMark })
    shouldApplyBackpressure(queueSize)
    size()
  }
</code></pre>

<h4 id="cqs-internal-slots">Internal Slots</h4>

Instances of <code>CountQueuingStrategy</code> are created with the internal slots described in the following table:

<table>
  <thead>
    <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
    </tr>
  </thead>
  <tr>
    <td>\[[highWaterMark]]
    <td>A nonnegative number that determines when the strategy applies <a>backpressure</a>
  </tr>
</table>

<h4 id="blqs-constructor">new CountQueuingStrategy({ highWaterMark })</h4>

<div class="note">
  The constructor takes a nonnegative number for the high-water mark, and stores it for later use.
</div>

<ol>
  <li> Let <var>highWaterMark</var> be ToNumber(<var>highWaterMark</var>).
  <li> If <var>highWaterMark</var> is <b>NaN</b>, throw a <b>TypeError</b> exception.
  <li> If <var>highWaterMark</var> &lt; 0, throw a <b>RangeError</b> exception.
  <li> Set <b>this</b>@\[[highWaterMark]] to <var>highWaterMark</var>.
</ol>

<h4 id="blqs-prototype">Properties of the <code>CountQueuingStrategy</code> Prototype</h4>

<h5 id="blqs-should-apply-backpressure">shouldApplyBackpressure(queueSize)</h5>

<div class="note">
  The <code>shouldApplyBackpressure</code> method returns whether or not the given queue size is greater than the
  queuing strategy's high-water mark.
</div>

<ol>
  <li> Let <var>queueSize</var> be ToNumber(<var>queueSize</var>).
  <li> If <var>queueSize</var> is <b>NaN</b>, return <b>false</b>.
  <li> Return <var>queueSize</var> > <b>this</b>@\[[highWaterMark]].
</ol>

<h5 id="blqs-size">size()</h5>

<div class="note">
  The <code>size</code> method returns one always, so that the total queue size is a count of the number of chunks in
  the queue.
</div>

<ol>
  <li> Return 1.
</ol>

<h3 id="queue-with-sizes">Queue-with-Sizes Operations</h3>

The streams in this specification use a "queue-with-sizes" data structure to store queued up values, along with their
determined sizes. A queue-with-sizes is a List of Records with \[[value]] and \[[size]] fields (although in
implementations it would of course be backed by a more efficient data structure).

A number of abstract operations are specified here to make working with queues-with-sizes more pleasant, and used
throughout the rest of this standard.

<h4 id="dequeue-value">DequeueValue ( queue )</h4>

<ol>
  <li> Assert: <var>queue</var> is not empty.
  <li> Let <var>pair</var> be the first element of queue.
  <li> Remove <var>pair</var> from <var>queue</var>, shifting all other elements downward (so that the second becomes
    the first, and so on).
  <li> Return <var>pair</var>.\[[value]].
</ol>

<h4 id="enqueue-value-with-size">EnqueueValueWithSize ( queue, value, size )</h4>

<ol>
  <li> Let <var>size</var> be ToNumber(<var>size</var>).
  <li> ReturnIfAbrupt(<var>size</var>).
  <li> If <var>size</var> is <b>NaN</b>, <b>+∞</b>, or <b>−∞</b>, throw a <b>RangeError</b> exception.
  <li> Append Record{\[[value]]: <var>value</var>, \[[size]]: <var>size</var>} as the last element of <var>queue</var>.
</ol>

<h4 id="get-total-queue-size">GetTotalQueueSize ( queue )</h4>

<ol>
  <li> Let <var>totalSize</var> be <b>0</b>.
  <li> Repeat for each Record{\[[value]], \[[size]]} <var>pair</var> that is an element of <var>queue</var>,
    <ol>
      <li> Assert: <var>pair</var>.\[[size]] is a finite, non-<b>NaN</b> number.
      <li> Add <var>pair</var>.\[[size]] to <var>totalSize</var>.
    </ol>
  <li> Return <var>totalSize</var>.
</ol>

<h4 id="peek-queue-value">PeekQueueValue ( queue )</h4>

<ol>
  <li> Assert: <var>queue</var> is not empty.
  <li> Let <var>pair</var> be the first element of <var>queue</var>.
  <li> Return <var>pair</var>.\[[value]].
</ol>

<h2 id="subclassing">Subclassing Streams</h2>

<em>This section is non-normative.</em>

Specific APIs may wish to subclass <code>ReadableStream</code> or <code>WritableStream</code> in order to provide
additional functionality. Examples would include:

<ul>
  <li>A file stream that is constructed from a filename, and includes file metadata</li>
  <li>A HTTP stream that is constructed from a URL, and includes header-accessing APIs</li>
  <li>A TCP stream that overrides <code>read</code>, <code>ready</code>, <code>cancel</code>, <code>state</code>, and
  <code>closed</code> to reflect and manipulate a kernel-level TCP buffer</li>
</ul>

The first two examples here could be expressed by allowing their constructors to call <code>super</code> with
appropriate functions that manipulate the stream's internal state. The latter takes a different approach, which gives
both more power and more responsibility: it requires that the author of that stream manually implement many of the
complex requirements baked into the readable stream state machine and the contract it presents to users.

Because streams only interact through their public API, all streams—whether subclassed or not—can coexist and
interoperate. For example, you can pipe to or from any of the above streams, without worrying what type of
implementation is under the covers, since they all provide the appropriate properties and methods.

<h2 id="conventions" class="no-num">Conventions</h2>

This specification uses algorithm conventions very similar to those of [[!ECMASCRIPT]]. However, it deviates in the
following ways, mostly for brevity. It is hoped (and vaguely planned) that eventually the conventions of ECMAScript
itself will evolve in these ways.

<ul>
  <li> We use destructuring notation in function and method declarations, and assume that the destructuring assignment
    procedure was performed before the algorithm starts.
  <li> We similarly use the default argument notation <code>= {}</code> in a couple of cases.
  <li> We use the notation <var>x</var>@\[[y]] to refer to internal slots of an object, instead of saying "the \[[y]]
    internal slot of <var>x</var>."
  <li> We do not alias <b>this</b> to a local variable in each algorithm, instead using it directly.
  <li> We use the phrase "calling <var>x</var>(<var>y</var>, <var>z</var>, w</var>)" as a shorthand for "calling the
    \[[Call]] internal method of <var>x</var> passing <b>undefined</b> as <var>thisArgument</var> and (<var>y</var>,
    <var>z</var>, <var>w</var>) as <var>argumentsList</var>."
  <li> We use the phrase "call-with-rethrow AbstractOperation(<var>x</var>, <var>y</var>, <var>z</var>)" as a shorthand
    for "Let <var>opResult</var> be AbstractOperation(<var>x</var>, <var>y</var>, <var>z</var>).
    ReturnIfAbrupt(<var>opResult</var>)."
  <li> We use <a href="https://w3ctag.github.io/promises-guide/#shorthand-phrases">the shorthand phrases from the W3C
    TAG promises guide</a> to operate on promises at a higher level than the ECMAScript spec does.
  <li> We introduce the notion of creating a function that "closes over" a given variable. This is meant to work the
    same as how the ECMAScript spec gives such functions internal slots which get filled in upon creation and then
    have their values pulled out of during execution, but require less formal contortions.
  <li> We have use the phrase "no-op function" as a shorthand, without bothering to give it a formal definition.
</ul>

<h2 id="acks" class="no-num">Acknowledgments</h2>

The editor would like to thank
Tab Atkins,
Bert Belder,
Marcos Caceres,
Tim Caswell,
Brian di Palma,
Forbes Lindesay,
Thorsten Lorenz,
Michael Mior,
Jens Nockert,
Trevor Norris,
Dominic Tarr, and
tzik
for their contributions to this specification.

Special thanks to:
Will Chan for his help ensuring that the API allows high-performance network streaming,
Janessa Det for the logo,
Gorgi Kosev for his breakthrough idea of separating piping into two methods, thus resolving
  <a href="https://github.com/whatwg/streams/issues/44">a major sticking point</a>;
Forrest Norvell for his enthusiastic iteration on the reference implementation;
Isaac Schlueter for his pioneering work on JavaScript streams in Node.js; and
Jake Verbaten for his continued involvement, support, and interest in pushing this spec forward.

This standard is written by <a href="https://domenic.me/">Domenic Denicola</a>
(<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>) with substantial help from
Takeshi Yoshino (<a href="https://google.com">Google</a>,
<a href="mailto:tyoshino@chromium.org">tyoshino@chromium.org</a>).

Per <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to the extent possible under law, the editor has waived all copyright and related or neighboring rights to this work.
